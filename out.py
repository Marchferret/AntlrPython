from phi import *
from __future__ import print_function,division
import collections
from mpmath.libmp.libmpf import prec_to_dps
from sympy.assumptions.refine import refine
from sympy.core.add import Add
from sympy.core.basic import Basic,Atom
from sympy.core.expr import Expr
from sympy.core.function import expand_mul
from sympy.core.power import Pow
from sympy.core.symbol import (Symbol,Dummy,symbols,_uniquely_named_symbol)
from sympy.core.numbers import Integer,ilcm,Float
from sympy.core.singleton import S
from sympy.core.sympify import sympify
from sympy.functions.elementary.miscellaneous import sqrt,Max,Min
from sympy.functions import Abs,exp,factorial
from sympy.polys import PurePoly,roots,cancel,gcd
from sympy.printing import sstr
from sympy.simplify import simplify as _simplify,signsimp,nsimplify
from sympy.core.compatibility import reduce,as_int,string_types
from sympy.utilities.iterables import flatten,numbered_symbols
from sympy.core.decorators import call_highest_priority
from sympy.core.compatibility import (is_sequence,default_sort_key,range,NotIterable)
from types import FunctionType
from .common import (a2idx,classof,MatrixError,ShapeError,NonSquareMatrixError,MatrixCommon)
def _iszero(x):
    x_0 = x;
    

    """Returns True if x is zero.""" 
    try:
        return x_0.is_zero
    except AttributeError:
        return None

def _is_zero_after_expand_mul(x):
    x_1 = x;
    

    """Tests by expand_mul only, suitable for polynomials and rational
    functions.""" 
    return expand_mul(x_1)==0

class DeferredVector(Symbol,NotIterable):
    """A vector whose components are deferred (e.g. for use with lambdify)

    Examples
    ========

    >>> from sympy import DeferredVector, lambdify
    >>> X = DeferredVector( 'X' )
    >>> X
    X
    >>> expr = (X[0] + 2, X[2] + 3)
    >>> func = lambdify( X, expr)
    >>> func( [1, 2, 3] )
    (3, 6)
    """ 
    def __getitem__(self,i):
        i_0 = i;
        component_name_0=None;i_1=None;i_2=None;

        if i_0==-0:
            i_1=0 
        phiPreds = [i_0==-0]
        phiNames = [i_1,i_0]
        i_2= phiIf(phiPreds, phiNames)
        if i_2<0:
            raise IndexError('DeferredVector index out of range')
        component_name_0='%s[%d]'%(self.name,i_2) 
        return Symbol(component_name_0)

    def __str__(self):
        
        

        return sstr(self)

    def __repr__(self):
        
        

        return "DeferredVector('%s')"%self.name

class MatrixDeterminant(MatrixCommon):
    """Provides basic matrix determinant operations.
    Should not be instantiated directly.""" 
    def _eval_berkowitz_toeplitz_matrix(self):
        
        a_0=None;A_0=None;R_0=None;C_0=None;i_4=None;diags_0=None;diags_1=None;diags_2=None;j_0=None;toeplitz_0=None;

        """Return (A,T) where T the Toeplitz matrix used in the Berkowitz algorithm
        corresponding to `self` and A is the first principal submatrix.""" 
        if self.rows==0 and self.cols==0:
            return self._new(1,1,[S.One])
        a_0,R_0=self[0,0],self[0,1:] 
        C_0,A_0=self[1:,0],self[1:,1:] 
        diags_0=[C_0] 
        phi0 = Phi()
        for i_3 in range(self.rows-2):
            phi0.set()

            diags_0.append(A_0*diags_0[i_3]) 
        diags_1=[(-R_0*d_0)[0,0] for d_0 in diags_0] 
        diags_2=[S.One,-a_0]+diags_1 
        def entry(i,j):
            i_4 = i;j_0 = j;
            

            if j_0>i_4:
                return S.Zero
            return diags_2[i_4-j_0]

        toeplitz_0=self._new(self.cols+1,self.rows,entry) 
        return (A_0,toeplitz_0)

    def _eval_berkowitz_vector(self):
        
        toeplitz_1=None;submat_0=None;

        """ Run the Berkowitz algorithm and return a vector whose entries
            are the coefficients of the characteristic polynomial of `self`.

            Given N x N matrix, efficiently compute
            coefficients of characteristic polynomials of 'self'
            without division in the ground domain.

            This method is particularly useful for computing determinant,
            principal minors and characteristic polynomial when 'self'
            has complicated coefficients e.g. polynomials. Semi-direct
            usage of this algorithm is also important in computing
            efficiently sub-resultant PRS.

            Assuming that M is a square matrix of dimension N x N and
            I is N x N identity matrix, then the Berkowitz vector is
            an N x 1 vector whose entries are coefficients of the
            polynomial

                           charpoly(M) = det(t*I - M)

            As a consequence, all polynomials generated by Berkowitz
            algorithm are monic.

           For more information on the implemented algorithm refer to:

           [1] S.J. Berkowitz, On computing the determinant in small
               parallel time using a small number of processors, ACM,
               Information Processing Letters 18, 1984, pp. 147-150

           [2] M. Keber, Division-Free computation of sub-resultants
               using Bezout matrices, Tech. Report MPI-I-2006-1-006,
               Saarbrucken, 2006
        """ 
        if self.rows==0 and self.cols==0:
            return self._new(1,1,[S.One])
        elif self.rows==1 and self.cols==1:
            return self._new(2,1,[S.One,-self[0,0]])
        submat_0,toeplitz_1=self._eval_berkowitz_toeplitz_matrix() 
        return toeplitz_1*submat_0._eval_berkowitz_vector()

    def _eval_det_bareiss(self):
        
        pivot_val_0=None;ret_0=None;mat_0=None;tmp_mat_0=None;pivot_pos_0=None;sign_0=None;i_6=None;j_1=None;cumm_0=None;rows_0=None;cols_0=None;

        """Compute matrix determinant using Bareiss' fraction-free
        algorithm which is an extension of the well known Gaussian
        elimination method. This approach is best suited for dense
        symbolic matrices and will result in a determinant with
        minimal number of fractions. It means that less term
        rewriting is needed on resulting formulae.

        TODO: Implement algorithm for sparse matrices (SFF),
        http://www.eecis.udel.edu/~saunders/papers/sffge/it5.ps.
        """ 
        def bareiss(mat,cumm=1):
            mat_0 = mat;cumm_0 = cumm;
            pivot_val_0=None;ret_0=None;tmp_mat_0=None;pivot_pos_0=None;sign_0=None;i_6=None;j_1=None;rows_0=None;cols_0=None;

            if mat_0.rows==0:
                return S.One
            elif mat_0.rows==1:
                return mat_0[0,0]
            pivot_pos_0,pivot_val_0,_,_=_find_reasonable_pivot(mat_0[:,0],iszerofunc=_is_zero_after_expand_mul) 
            if pivot_pos_0==None:
                return S.Zero
            sign_0=(-1)**(pivot_pos_0%2) 
            rows_0=list(i_5 for i_5 in range(mat_0.rows) if i_5!=pivot_pos_0) 
            cols_0=list(range(mat_0.cols)) 
            tmp_mat_0=mat_0.extract(rows_0,cols_0) 
            def entry(i,j):
                i_6 = i;j_1 = j;
                ret_0=None;

                ret_0=(pivot_val_0*tmp_mat_0[i_6,j_1+1]-mat_0[pivot_pos_0,j_1+1]*tmp_mat_0[i_6,0])/cumm_0 
                if  not ret_0.is_Atom:
                    cancel(ret_0) 
                return ret_0

            return sign_0*bareiss(self._new(mat_0.rows-1,mat_0.cols-1,entry),pivot_val_0)

        return cancel(bareiss(self))

    def _eval_det_berkowitz(self):
        
        berk_vector_0=None;

        """ Use the Berkowitz algorithm to compute the determinant.""" 
        berk_vector_0=self._eval_berkowitz_vector() 
        return (-1)**(len(berk_vector_0)-1)*berk_vector_0[-1]

    def _eval_det_lu(self,iszerofunc=_iszero,simpfunc=None):
        iszerofunc_0 = iszerofunc;simpfunc_0 = simpfunc;
        row_swaps_0=None;det_0=None;det_2=None;det_1=None;det_3=None;lu_0=None;

        """ Computes the determinant of a matrix from its LU decomposition.
        This function uses the LU decomposition computed by
        LUDecomposition_Simple().

        The keyword arguments iszerofunc and simpfunc are passed to
        LUDecomposition_Simple().
        iszerofunc is a callable that returns a boolean indicating if its
        input is zero, or None if it cannot make the determination.
        simpfunc is a callable that simplifies its input.
        The default is simpfunc=None, which indicate that the pivot search
        algorithm should not attempt to simplify any candidate pivots.
        If simpfunc fails to simplify its input, then it must return its input
        instead of a copy.""" 
        if self.rows==0:
            return S.One
        lu_0,row_swaps_0=self.LUdecomposition_Simple(iszerofunc=iszerofunc_0,simpfunc_0= None ) 
        if iszerofunc_0(lu_0[lu_0.rows-1,lu_0.rows-1]):
            return S.Zero
        det_0=-S.One if len(row_swaps_0)%2 else S.One 
        phi0 = Phi()
        for k_0 in range(lu_0.rows):
            phi0.set()
            det_2 = phi0.phiEntry(det_0,det_1)

            det_1 = det_2*lu_0[k_0,k_0]
        det_3 = phi0.phiExit(det_0,det_1)
        return det_3

    def _eval_determinant(self):
        
        

        """Assumed to exist by matrix expressions; If we subclass
        MatrixDeterminant, we can fully evaluate determinants.""" 
        return self.det()

    def adjugate(self,method="berkowitz"):
        method_0 = method;
        

        """Returns the adjugate, or classical adjoint, of
        a matrix.  That is, the transpose of the matrix of cofactors.


        http://en.wikipedia.org/wiki/Adjugate

        See Also
        ========

        cofactor_matrix
        transpose
        """ 
        return self.cofactor_matrix(method_0).transpose()

    def charpoly(self,x='lambda',simplify=_simplify):
        x_2 = x;simplify_0 = simplify;
        berk_vector_1=None;x_3=None;

        """Computes characteristic polynomial det(x*I - self) where I is
        the identity matrix.

        A PurePoly is returned, so using different variables for ``x`` does
        not affect the comparison or the polynomials:

        Examples
        ========

        >>> from sympy import Matrix
        >>> from sympy.abc import x, y
        >>> A = Matrix([[1, 3], [2, 0]])
        >>> A.charpoly(x) == A.charpoly(y)
        True

        Specifying ``x`` is optional; a symbol named ``lambda`` is used by
        default (which looks good when pretty-printed in unicode):

        >>> A.charpoly().as_expr()
        lambda**2 - lambda - 6

        And if ``x`` clashes with an existing symbol, underscores will
        be preppended to the name to make it unique:

        >>> A = Matrix([[1, 2], [x, 0]])
        >>> A.charpoly(x).as_expr()
        _x**2 - _x - 2*x

        Whether you pass a symbol or not, the generator can be obtained
        with the gen attribute since it may not be the same as the symbol
        that was passed:

        >>> A.charpoly(x).gen
        _x
        >>> A.charpoly(x).gen == x
        False

        Notes
        =====

        The Samuelson-Berkowitz algorithm is used to compute
        the characteristic polynomial efficiently and without any
        division operations.  Thus the characteristic polynomial over any
        commutative ring without zero divisors can be computed.

        See Also
        ========

        det
        """ 
        if self.rows!=self.cols:
            raise NonSquareMatrixError()
        berk_vector_1=self._eval_berkowitz_vector() 
        x_3=_uniquely_named_symbol(x_2,berk_vector_1) 
        return PurePoly([simplify_0(a_1) for a_1 in berk_vector_1],x_3)

    def cofactor(self,i,j,method="berkowitz"):
        i_7 = i;j_2 = j;method_1 = method;
        

        """Calculate the cofactor of an element.

        See Also
        ========

        cofactor_matrix
        minor
        minor_submatrix
        """ 
        if self.rows!=self.cols or self.rows<1:
            raise NonSquareMatrixError()
        return (-1)**((i_7+j_2)%2)*self.minor(i_7,j_2,method_1)

    def cofactor_matrix(self,method="berkowitz"):
        method_2 = method;
        i_8=None;j_3=None;

        """Return a matrix containing the cofactor of each element.

        See Also
        ========

        cofactor
        minor
        minor_submatrix
        adjugate
        """ 
        if self.rows!=self.cols or self.rows<1:
            raise NonSquareMatrixError()
        return self._new(self.rows,self.cols, lambda i_8 , j_3 :self.cofactor(i_8,j_3,method_2))

    def det(self,method="bareiss"):
        method_3 = method;
        method_4=None;method_5=None;method_6=None;method_7=None;method_8=None;n_0=None;

        """Computes the determinant of a matrix.  If the matrix
        is at most 3x3, a hard-coded formula is used.
        Otherwise, the determinant using the method `method`.


        Possible values for "method":
          bareis
          berkowitz
          lu
        """ 
        method_4=method_3.lower() 
        if method_4=="bareis":
            method_5="bareiss" 
        phiPreds = [method_4=="bareis"]
        phiNames = [method_5,method_4]
        method_6= phiIf(phiPreds, phiNames)
        if method_6=="det_lu":
            method_7="lu" 
        phiPreds = [method_6=="det_lu"]
        phiNames = [method_7,method_6]
        method_8= phiIf(phiPreds, phiNames)
        if method_8 not  in ("bareiss","berkowitz","lu"):
            raise ValueError("Determinant method '%s' unrecognized"%method_8)
        if self.rows!=self.cols:
            raise NonSquareMatrixError()
        n_0=self.rows 
        if n_0==0:
            return S.One
        elif n_0==1:
            return self[0,0]
        elif n_0==2:
            return self[0,0]*self[1,1]-self[0,1]*self[1,0]
        elif n_0==3:
            return (self[0,0]*self[1,1]*self[2,2]+self[0,1]*self[1,2]*self[2,0]+self[0,2]*self[1,0]*self[2,1]-self[0,2]*self[1,1]*self[2,0]-self[0,0]*self[1,2]*self[2,1]-self[0,1]*self[1,0]*self[2,2])
        if method_8=="bareiss":
            return self._eval_det_bareiss()
        elif method_8=="berkowitz":
            return self._eval_det_berkowitz()
        elif method_8=="lu":
            return self._eval_det_lu()

    def minor(self,i,j,method="berkowitz"):
        i_9 = i;j_4 = j;method_9 = method;
        

        """Return the (i,j) minor of `self`.  That is,
        return the determinant of the matrix obtained by deleting
        the `i`th row and `j`th column from `self`.

        See Also
        ========

        minor_submatrix
        cofactor
        det
        """ 
        if self.rows!=self.cols or self.rows<1:
            raise NonSquareMatrixError()
        return self.minor_submatrix(i_9,j_4).det(method_9=method_9)

    def minor_submatrix(self,i,j):
        i_10 = i;j_5 = j;
        i_11=None;i_12=None;j_6=None;j_7=None;rows_1=None;cols_1=None;

        """Return the submatrix obtained by removing the `i`th row
        and `j`th column from `self`.

        See Also
        ========

        minor
        cofactor
        """ 
        if i_10<0:
            i_11 = i_10+self.rows
        phiPreds = [i_10<0]
        phiNames = [i_11,i_10]
        i_12= phiIf(phiPreds, phiNames)
        if j_5<0:
            j_6 = j_5+self.cols
        phiPreds = [j_5<0]
        phiNames = [j_6,j_5]
        j_7= phiIf(phiPreds, phiNames)
        if  not 0<=i_12<self.rows or  not 0<=j_7<self.cols:
            raise ValueError("`i` and `j` must satisfy 0 <= i < `self.rows` ""(%d)"%self.rows+"and 0 <= j < `self.cols` (%d)."%self.cols)
        rows_1=[a_2 for a_2 in range(self.rows) if a_2!=i_12] 
        cols_1=[a_3 for a_3 in range(self.cols) if a_3!=j_7] 
        return self.extract(rows_1,cols_1)

class MatrixReductions(MatrixDeterminant):
    """Provides basic matrix row/column operations.
    Should not be instantiated directly.""" 
    def _eval_col_op_swap(self,col1,col2):
        col1_0 = col1;col2_0 = col2;
        i_13=None;j_8=None;

        def entry(i,j):
            i_13 = i;j_8 = j;
            

            if j_8==col1_0:
                return self[i_13,col2_0]
            elif j_8==col2_0:
                return self[i_13,col1_0]
            return self[i_13,j_8]

        return self._new(self.rows,self.cols,entry)

    def _eval_col_op_multiply_col_by_const(self,col,k):
        col_0 = col;k_1 = k;
        i_14=None;j_9=None;

        def entry(i,j):
            i_14 = i;j_9 = j;
            

            if j_9==col_0:
                return k_1*self[i_14,j_9]
            return self[i_14,j_9]

        return self._new(self.rows,self.cols,entry)

    def _eval_col_op_add_multiple_to_other_col(self,col,k,col2):
        col_1 = col;k_2 = k;col2_1 = col2;
        i_15=None;j_10=None;

        def entry(i,j):
            i_15 = i;j_10 = j;
            

            if j_10==col_1:
                return self[i_15,j_10]+k_2*self[i_15,col2_1]
            return self[i_15,j_10]

        return self._new(self.rows,self.cols,entry)

    def _eval_row_op_swap(self,row1,row2):
        row1_0 = row1;row2_0 = row2;
        i_16=None;j_11=None;

        def entry(i,j):
            i_16 = i;j_11 = j;
            

            if i_16==row1_0:
                return self[row2_0,j_11]
            elif i_16==row2_0:
                return self[row1_0,j_11]
            return self[i_16,j_11]

        return self._new(self.rows,self.cols,entry)

    def _eval_row_op_multiply_row_by_const(self,row,k):
        row_0 = row;k_3 = k;
        i_17=None;j_12=None;

        def entry(i,j):
            i_17 = i;j_12 = j;
            

            if i_17==row_0:
                return k_3*self[i_17,j_12]
            return self[i_17,j_12]

        return self._new(self.rows,self.cols,entry)

    def _eval_row_op_add_multiple_to_other_row(self,row,k,row2):
        row_1 = row;k_4 = k;row2_1 = row2;
        i_18=None;j_13=None;

        def entry(i,j):
            i_18 = i;j_13 = j;
            

            if i_18==row_1:
                return self[i_18,j_13]+k_4*self[row2_1,j_13]
            return self[i_18,j_13]

        return self._new(self.rows,self.cols,entry)

    def _eval_echelon_form(self,iszerofunc,simpfunc):
        iszerofunc_1 = iszerofunc;simpfunc_1 = simpfunc;
        reduced_0=None;pivot_cols_0=None;swaps_0=None;

        """Returns (mat, swaps) where `mat` is a row-equivalent matrix
        in echelon form and `swaps` is a list of row-swaps performed.""" 
        reduced_0,pivot_cols_0,swaps_0=self._row_reduce(iszerofunc_1,simpfunc_1,normalize_last=True,normalize=False,zero_above=False) 
        return reduced_0,pivot_cols_0,swaps_0

    def _eval_is_echelon(self,iszerofunc):
        iszerofunc_2 = iszerofunc;
        zeros_below_0=None;

        if self.rows<=0 or self.cols<=0:
            return True
        zeros_below_0=all(iszerofunc_2(t_0) for t_0 in self[1:,0]) 
        if iszerofunc_2(self[0,0]):
            return zeros_below_0 and self[:,1:]._eval_is_echelon(iszerofunc_2)
        return zeros_below_0 and self[1:,1:]._eval_is_echelon(iszerofunc_2)

    def _eval_rref(self,iszerofunc,simpfunc,normalize_last=True):
        iszerofunc_3 = iszerofunc;simpfunc_2 = simpfunc;normalize_last_0 = normalize_last;
        reduced_1=None;pivot_cols_1=None;swaps_1=None;

        reduced_1,pivot_cols_1,swaps_1=self._row_reduce(iszerofunc_3,simpfunc_2,normalize_last_0,normalize=True,zero_above=True) 
        return reduced_1,pivot_cols_1

    def _normalize_op_args(self,op,col,k,col1,col2,error_str="col"):
        op_0 = op;col_2 = col;k_5 = k;col1_1 = col1;col2_2 = col2;error_str_0 = error_str;
        col_3=None;col_4=None;col_5=None;col_6=None;col2_3=None;col2_4=None;col2_5=None;col2_6=None;cols_2=None;cols_3=None;cols_4=None;cols_5=None;col1_2=None;col1_3=None;

        """Validate the arguments for a row/column operation.  `error_str`
        can be one of "row" or "col" depending on the arguments being parsed.""" 
        if op_0 not  in ["n->kn","n<->m","n->n+km"]:
            raise ValueError("Unknown {} operation '{}'. Valid col operations ""are 'n->kn', 'n<->m', 'n->n+km'".format(error_str_0,op_0))
        if op_0=="n->kn":
            col_3=col_2 if col_2 is  not  None  else col1_1 
            if col_3 is None or k_5 is None:
                raise ValueError("For a {0} operation 'n->kn' you must provide the ""kwargs `{0}` and `k`".format(error_str_0))
            if  not 0<=col_3<=self.cols:
                raise ValueError("This matrix doesn't have a {} '{}'".format(error_str_0,col_3))
        phiPreds = [op_0=="n->kn"]
        phiNames = [col_3,col_2]
        col_4= phiIf(phiPreds, phiNames)
        if op_0=="n<->m":
            cols_2=set((col_4,k_5,col1_1,col2_2)).difference([ None ]) 
            if len(cols_2)>2:
                cols_3=set((col_4,col1_1,col2_2)).difference([ None ]) 
            phiPreds = [len(cols_2)>2]
            phiNames = [cols_3,cols_2]
            cols_4= phiIf(phiPreds, phiNames)
            if len(cols_4)!=2:
                raise ValueError("For a {0} operation 'n<->m' you must provide the ""kwargs `{0}1` and `{0}2`".format(error_str_0))
            col1_2,col2_3=cols_4 
            if  not 0<=col1_2<=self.cols:
                raise ValueError("This matrix doesn't have a {} '{}'".format(error_str_0,col1_2))
            if  not 0<=col2_3<=self.cols:
                raise ValueError("This matrix doesn't have a {} '{}'".format(error_str_0,col2_3))
        phiPreds = [op_0=="n<->m"]
        phiNames = [col2_3,col2_2]
        col2_4= phiIf(phiPreds, phiNames)
        phiPreds = [op_0=="n<->m"]
        phiNames = [cols_4,None]
        cols_5= phiIf(phiPreds, phiNames)
        phiPreds = [op_0=="n<->m"]
        phiNames = [col1_2,col1_1]
        col1_3= phiIf(phiPreds, phiNames)
        if op_0=="n->n+km":
            col_5=col1_3 if col_4 is  None  else col_4 
            col2_5=col1_3 if col2_4 is  None  else col2_4 
            if col_5 is None or col2_5 is None or k_5 is None:
                raise ValueError("For a {0} operation 'n->n+km' you must provide the ""kwargs `{0}`, `k`, and `{0}2`".format(error_str_0))
            if col_5==col2_5:
                raise ValueError("For a {0} operation 'n->n+km' `{0}` and `{0}2` must ""be different.".format(error_str_0))
            if  not 0<=col_5<=self.cols:
                raise ValueError("This matrix doesn't have a {} '{}'".format(error_str_0,col_5))
            if  not 0<=col2_5<=self.cols:
                raise ValueError("This matrix doesn't have a {} '{}'".format(error_str_0,col2_5))
        phiPreds = [op_0=="n->n+km"]
        phiNames = [col_5,col_4]
        col_6= phiIf(phiPreds, phiNames)
        phiPreds = [op_0=="n->n+km"]
        phiNames = [col2_5,col2_4]
        col2_6= phiIf(phiPreds, phiNames)
        return op_0,col_6,k_5,col1_3,col2_6

    def _permute_complexity_right(self,iszerofunc):
        iszerofunc_4 = iszerofunc;
        perm_0=None;complex_0=None;i_19=None;

        """Permute columns with complicated elements as
        far right as they can go.  Since the `sympy` row reduction
        algorithms start on the left, having complexity right-shifted
        speeds things up.

        Returns a tuple (mat, perm) where perm is a permutation
        of the columns to perform to shift the complex columns right, and mat
        is the permuted matrix.""" 
        def complexity(i):
            i_19 = i;
            

            return sum(1 if iszerofunc_4(e_0) is None else 0 for e_0 in self[:,i_19])

        complex_0=[(complexity(i_20),i_20) for i_20 in range(self.cols)] 
        perm_0=[j_14 for (i_21,j_14) in sorted(complex_0)] 
        return (self.permute(perm_0,orientation='cols'),perm_0)

    def _row_reduce(self,iszerofunc,simpfunc,normalize_last=True,normalize=True,zero_above=True):
        iszerofunc_5 = iszerofunc;simpfunc_3 = simpfunc;normalize_last_1 = normalize_last;normalize_0 = normalize;zero_above_0 = zero_above;
        pivot_val_4=None;pivot_val_1=None;pivot_val_2=None;pivot_val_3=None;pivot_val_5=None;pivot_val_7=None;pivot_val_6=None;pivot_val_8=None;pivot_val_9=None;val_4=None;val_2=None;val_1=None;val_3=None;val_5=None;mat_1=None;a_4=None;b_0=None;offset_4=None;offset_2=None;offset_1=None;offset_3=None;offset_5=None;i_22=None;i_23=None;i_24=None;i_27=None;i_25=None;i_26=None;i_28=None;j_15=None;j_16=None;j_19=None;j_17=None;j_18=None;j_20=None;piv_row_0=None;piv_row_2=None;piv_row_1=None;piv_row_3=None;pivot_offset_1=None;pivot_offset_0=None;pivot_offset_2=None;rows_2=None;piv_col_0=None;piv_col_3=None;piv_col_1=None;piv_col_2=None;piv_col_4=None;swaps_2=None;q_0=None;newly_determined_1=None;newly_determined_0=None;newly_determined_2=None;assumed_nonzero_1=None;assumed_nonzero_0=None;assumed_nonzero_2=None;pivot_cols_2=None;cols_6=None;

        """Row reduce `self` and return a tuple (rref_matrix,
        pivot_cols, swaps) where pivot_cols are the pivot columns
        and swaps are any row swaps that were used in the process
        of row reduction.

        Parameters
        ==========

        iszerofunc : determines if an entry can be used as a pivot
        simpfunc : used to simplify elements and test if they are
            zero if `iszerofunc` returns `None`
        normalize_last : indicates where all row reduction should
            happen in a fraction-free manner and then the rows are
            normalized (so that the pivots are 1), or whether
            rows should be normalized along the way (like the naive
            row reduction algorithm)
        normalize : whether pivot rows should be normalized so that
            the pivot value is 1
        zero_above : whether entries above the pivot should be zeroed.
            If `zero_above=False`, an echelon matrix will be returned.
        """ 
        rows_2,cols_6=self.rows,self.cols 
        mat_1=list(self) 
        def get_col(i):
            i_22 = i;
            

            return mat_1[i_22::cols_6]

        def row_swap(i,j):
            i_23 = i;j_15 = j;
            

            mat_1[i_23*cols_6:(i_23+1)*cols_6],mat_1[j_15*cols_6:(j_15+1)*cols_6]=mat_1[j_15*cols_6:(j_15+1)*cols_6],mat_1[i_23*cols_6:(i_23+1)*cols_6] 

        def cross_cancel(a,i,b,j):
            a_4 = a;i_24 = i;b_0 = b;j_16 = j;
            q_0=None;

            """Does the row op row[i] = a*row[i] - b*row[j]""" 
            q_0=(j_16-i_24)*cols_6 
            phi0 = Phi()
            for p_0 in range(i_24*cols_6,(i_24+1)*cols_6):
                phi0.set()

                mat_1[p_0]=a_4*mat_1[p_0]-b_0*mat_1[p_0+q_0] 

        piv_row_0,piv_col_0=0,0 
        pivot_cols_2=[] 
        swaps_2=[] 
        phi0 = Phi()
        while phi0.phiLoopTest(piv_col_0,piv_col_2)<cols_6 and phi0.phiLoopTest(piv_row_0,piv_row_1)<rows_2:
            phi0.set()
            pivot_val_4 = phi0.phiEntry(None,pivot_val_3)
            val_4 = phi0.phiEntry(None,val_3)
            offset_4 = phi0.phiEntry(None,offset_3)
            newly_determined_1 = phi0.phiEntry(None,newly_determined_0)
            i_27 = phi0.phiEntry(i_24,i_26)
            assumed_nonzero_1 = phi0.phiEntry(None,assumed_nonzero_0)
            j_19 = phi0.phiEntry(j_16,j_18)
            piv_row_2 = phi0.phiEntry(piv_row_0,piv_row_1)
            pivot_offset_1 = phi0.phiEntry(None,pivot_offset_0)
            piv_col_3 = phi0.phiEntry(piv_col_0,piv_col_2)

            pivot_offset_0,pivot_val_1,assumed_nonzero_0,newly_determined_0=_find_reasonable_pivot(get_col(piv_col_3)[piv_row_2:],iszerofunc_5,simpfunc_3) 
            phi1 = Phi()
            for (offset_4,val_4) in newly_determined_0:
                phi1.set()
                offset_2 = phi1.phiEntry(offset_4,offset_1)

                offset_1 = offset_2+piv_row_2
                mat_1[offset_1*cols_6+piv_col_3]=val_4 
            offset_3 = phi1.phiExit(None,offset_1)
            if pivot_offset_0 is None:
                piv_col_1 = piv_col_3+1
                continue
            phiPreds = [pivot_offset_0 is None]
            phiNames = [piv_col_1,piv_col_3]
            piv_col_2= phiIf(phiPreds, phiNames)
            pivot_cols_2.append(piv_col_2) 
            if pivot_offset_0!=0:
                row_swap(piv_row_2,pivot_offset_0+piv_row_2) 
                swaps_2.append((piv_row_2,pivot_offset_0+piv_row_2)) 
            if normalize_last_1 is False:
                i_25,j_17=piv_row_2,piv_col_2 
                mat_1[i_25*cols_6+j_17]=S.One 
                phi1 = Phi()
                for p_1 in range(i_25*cols_6+j_17+1,(i_25+1)*cols_6):
                    phi1.set()

                    mat_1[p_1]=mat_1[p_1]/pivot_val_1 
                pivot_val_2=S.One 
            phiPreds = [normalize_last_1 is False]
            phiNames = [pivot_val_2,pivot_val_1]
            pivot_val_3= phiIf(phiPreds, phiNames)
            phiPreds = [normalize_last_1 is False]
            phiNames = [i_25,i_27]
            i_26= phiIf(phiPreds, phiNames)
            phiPreds = [normalize_last_1 is False]
            phiNames = [j_17,j_19]
            j_18= phiIf(phiPreds, phiNames)
            phi1 = Phi()
            for row_2 in range(rows_2):
                phi1.set()
                val_2 = phi1.phiEntry(val_4,val_1)

                if row_2==piv_row_2:
                    continue
                if zero_above_0 is False and row_2<piv_row_2:
                    continue
                val_1=mat_1[row_2*cols_6+piv_col_2] 
                if iszerofunc_5(val_1):
                    continue
                cross_cancel(pivot_val_3,row_2,val_1,piv_row_2) 
            val_3 = phi1.phiExit(None,val_1)
            piv_row_1 = piv_row_2+1
        pivot_val_5 = phi0.phiExit(None,pivot_val_3)
        val_5 = phi0.phiExit(None,val_3)
        offset_5 = phi0.phiExit(None,offset_3)
        newly_determined_2 = phi0.phiExit(None,newly_determined_0)
        i_28 = phi0.phiExit(i_24,i_26)
        assumed_nonzero_2 = phi0.phiExit(None,assumed_nonzero_0)
        j_20 = phi0.phiExit(j_16,j_18)
        piv_row_3 = phi0.phiExit(piv_row_0,piv_row_1)
        pivot_offset_2 = phi0.phiExit(None,pivot_offset_0)
        piv_col_4 = phi0.phiExit(piv_col_0,piv_col_2)
        if normalize_last_1 is True and normalize_0 is True:
            phi0 = Phi()
            for piv_i_0,piv_j_0 in enumerate(pivot_cols_2):
                phi0.set()
                pivot_val_7 = phi0.phiEntry(pivot_val_5,pivot_val_6)

                pivot_val_6=mat_1[piv_i_0*cols_6+piv_j_0] 
                mat_1[piv_i_0*cols_6+piv_j_0]=S.One 
                phi1 = Phi()
                for p_2 in range(piv_i_0*cols_6+piv_j_0+1,(piv_i_0+1)*cols_6):
                    phi1.set()

                    mat_1[p_2]=mat_1[p_2]/pivot_val_6 
            pivot_val_8 = phi0.phiExit(None,pivot_val_6)
        phiPreds = [normalize_last_1 is True and normalize_0 is True]
        phiNames = [pivot_val_8,pivot_val_5]
        pivot_val_9= phiIf(phiPreds, phiNames)
        return self._new(self.rows,self.cols,mat_1),tuple(pivot_cols_2),tuple(swaps_2)

    def echelon_form(self,iszerofunc=_iszero,simplify=False,with_pivots=False):
        iszerofunc_6 = iszerofunc;simplify_1 = simplify;with_pivots_0 = with_pivots;
        mat_2=None;pivots_0=None;swaps_3=None;simpfunc_4=None;

        """Returns a matrix row-equivalent to `self` that is
        in echelon form.  Note that echelon form of a matrix
        is *not* unique, however, properties like the row
        space and the null space are preserved.""" 
        simpfunc_4=simplify_1 if isinstance(simplify_1,FunctionType) else _simplify 
        mat_2,pivots_0,swaps_3=self._eval_echelon_form(iszerofunc_6,simpfunc_4) 
        if with_pivots_0:
            return mat_2,pivots_0
        return mat_2

    def elementary_col_op(self,op="n->kn",col=None,k=None,col1=None,col2=None):
        op_1 = op;col_7 = col;k_6 = k;col1_4 = col1;col2_7 = col2;
        op_2=None;col_8=None;k_7=None;col2_8=None;col1_5=None;

        """Performs the elementary column operation `op`.

        `op` may be one of

            * "n->kn" (column n goes to k*n)
            * "n<->m" (swap column n and column m)
            * "n->n+km" (column n goes to column n + k*column m)

        Parameters
        =========

        op : string; the elementary row operation
        col : the column to apply the column operation
        k : the multiple to apply in the column operation
        col1 : one column of a column swap
        col2 : second column of a column swap or column "m" in the column operation
               "n->n+km"
        """ 
        op_2,col_8,k_7,col1_5,col2_8=self._normalize_op_args(op_1,col_7,k_6,col1_4,col2_7,"col") 
        if op_2=="n->kn":
            return self._eval_col_op_multiply_col_by_const(col_8,k_7)
        if op_2=="n<->m":
            return self._eval_col_op_swap(col1_5,col2_8)
        if op_2=="n->n+km":
            return self._eval_col_op_add_multiple_to_other_col(col_8,k_7,col2_8)

    def elementary_row_op(self,op="n->kn",row=None,k=None,row1=None,row2=None):
        op_3 = op;row_3 = row;k_8 = k;row1_1 = row1;row2_2 = row2;
        op_4=None;row1_2=None;row_4=None;k_9=None;row2_3=None;

        """Performs the elementary row operation `op`.

        `op` may be one of

            * "n->kn" (row n goes to k*n)
            * "n<->m" (swap row n and row m)
            * "n->n+km" (row n goes to row n + k*row m)

        Parameters
        ==========

        op : string; the elementary row operation
        row : the row to apply the row operation
        k : the multiple to apply in the row operation
        row1 : one row of a row swap
        row2 : second row of a row swap or row "m" in the row operation
               "n->n+km"
        """ 
        op_4,row_4,k_9,row1_2,row2_3=self._normalize_op_args(op_3,row_3,k_8,row1_1,row2_2,"row") 
        if op_4=="n->kn":
            return self._eval_row_op_multiply_row_by_const(row_4,k_9)
        if op_4=="n<->m":
            return self._eval_row_op_swap(row1_2,row2_3)
        if op_4=="n->n+km":
            return self._eval_row_op_add_multiple_to_other_row(row_4,k_9,row2_3)

    @property
    def is_echelon(self,iszerofunc=_iszero):
        iszerofunc_7 = iszerofunc;
        

        """Returns `True` if he matrix is in echelon form.
        That is, all rows of zeros are at the bottom, and below
        each leading non-zero in a row are exclusively zeros.""" 
        return self._eval_is_echelon(iszerofunc_7)

    def rank(self,iszerofunc=_iszero,simplify=False):
        iszerofunc_8 = iszerofunc;simplify_2 = simplify;
        mat_3=None;det_4=None;det_5=None;echelon_form_0=None;pivots_1=None;swaps_4=None;simpfunc_5=None;zeros_0=None;zeros_1=None;zeros_2=None;zeros_3=None;

        """
        Returns the rank of a matrix

        >>> from sympy import Matrix
        >>> from sympy.abc import x
        >>> m = Matrix([[1, 2], [x, 1 - 1/x]])
        >>> m.rank()
        2
        >>> n = Matrix(3, 3, range(1, 10))
        >>> n.rank()
        2
        """ 
        simpfunc_5=simplify_2 if isinstance(simplify_2,FunctionType) else _simplify 
        if self.rows<=0 or self.cols<=0:
            return 0
        if self.rows<=1 or self.cols<=1:
            zeros=[iszerofunc_8(x_4) for x_4 in self] 
            if False in zeros:
                return 1
        if self.rows==2 and self.cols==2:
            zeros=[iszerofunc_8(x_5) for x_5 in self] 
            if  not False in zeros and  not None in zeros:
                return 0
            det_4=self.det() 
            if iszerofunc_8(det_4) and False in zeros:
                return 1
            if iszerofunc_8(det_4) is False:
                return 2
        phiPreds = [self.rows==2 and self.cols==2]
        phiNames = [det_4,None]
        det_5= phiIf(phiPreds, phiNames)
        mat_3,_=self._permute_complexity_right(iszerofunc=iszerofunc_8) 
        echelon_form_0,pivots_1,swaps_4=mat_3._eval_echelon_form(iszerofunc=iszerofunc_8,simpfunc=simpfunc_5) 
        return len(pivots_1)

    def rref(self,iszerofunc=_iszero,simplify=False,pivots=True,normalize_last=True):
        iszerofunc_9 = iszerofunc;simplify_3 = simplify;pivots_2 = pivots;normalize_last_2 = normalize_last;
        ret_1=None;ret_2=None;ret_3=None;pivot_cols_3=None;simpfunc_6=None;

        """Return reduced row-echelon form of matrix and indices of pivot vars.

        Parameters
        ==========

        iszerofunc : Function
            A function used for detecting whether an element can
            act as a pivot.  `lambda x: x.is_zero` is used by default.
        simplify : Function
            A function used to simplify elements when looking for a pivot.
            By default SymPy's `simplify`is used.
        pivots : True or False
            If `True`, a tuple containing the row-reduced matrix and a tuple
            of pivot columns is returned.  If `False` just the row-reduced
            matrix is returned.
        normalize_last : True or False
            If `True`, no pivots are normalized to `1` until after all entries
            above and below each pivot are zeroed.  This means the row
            reduction algorithm is fraction free until the very last step.
            If `False`, the naive row reduction procedure is used where
            each pivot is normalized to be `1` before row operations are
            used to zero above and below the pivot.

        Notes
        =====

        The default value of `normalize_last=True` can provide significant
        speedup to row reduction, especially on matrices with symbols.  However,
        if you depend on the form row reduction algorithm leaves entries
        of the matrix, set `noramlize_last=False`


        Examples
        ========

        >>> from sympy import Matrix
        >>> from sympy.abc import x
        >>> m = Matrix([[1, 2], [x, 1 - 1/x]])
        >>> m.rref()
        (Matrix([
        [1, 0],
        [0, 1]]), (0, 1))
        >>> rref_matrix, rref_pivots = m.rref()
        >>> rref_matrix
        Matrix([
        [1, 0],
        [0, 1]])
        >>> rref_pivots
        (0, 1)
        """ 
        simpfunc_6=simplify_3 if isinstance(simplify_3,FunctionType) else _simplify 
        ret_1,pivot_cols_3=self._eval_rref(iszerofunc=iszerofunc_9,simpfunc=simpfunc_6,normalize_last=normalize_last_2) 
        if pivots_2:
            ret_2=(ret_1,pivot_cols_3) 
        phiPreds = [pivots_2]
        phiNames = [ret_2,ret_1]
        ret_3= phiIf(phiPreds, phiNames)
        return ret_3

class MatrixSubspaces(MatrixReductions):
    """Provides methods relating to the fundamental subspaces
    of a matrix.  Should not be instantiated directly.""" 
    def columnspace(self,simplify=False):
        simplify_4 = simplify;
        reduced_2=None;pivots_3=None;

        """Returns a list of vectors (Matrix objects) that span columnspace of self

        Examples
        ========

        >>> from sympy.matrices import Matrix
        >>> m = Matrix(3, 3, [1, 3, 0, -2, -6, 0, 3, 9, 6])
        >>> m
        Matrix([
        [ 1,  3, 0],
        [-2, -6, 0],
        [ 3,  9, 6]])
        >>> m.columnspace()
        [Matrix([
        [ 1],
        [-2],
        [ 3]]), Matrix([
        [0],
        [0],
        [6]])]

        See Also
        ========

        nullspace
        rowspace
        """ 
        reduced_2,pivots_3=self.echelon_form(simplify=simplify_4,with_pivots_0=True) 
        return [self.col(i_29) for i_29 in pivots_3]

    def nullspace(self,simplify=False):
        simplify_5 = simplify;
        free_vars_0=None;vec_1=None;vec_0=None;vec_2=None;reduced_3=None;pivots_4=None;basis_0=None;

        """Returns list of vectors (Matrix objects) that span nullspace of self

        Examples
        ========

        >>> from sympy.matrices import Matrix
        >>> m = Matrix(3, 3, [1, 3, 0, -2, -6, 0, 3, 9, 6])
        >>> m
        Matrix([
        [ 1,  3, 0],
        [-2, -6, 0],
        [ 3,  9, 6]])
        >>> m.nullspace()
        [Matrix([
        [-3],
        [ 1],
        [ 0]])]

        See Also
        ========

        columnspace
        rowspace
        """ 
        reduced_3,pivots_4=self.rref(simplify=simplify_5) 
        free_vars_0=[i_30 for i_30 in range(self.cols) if i_30 not  in pivots_4] 
        basis_0=[] 
        phi0 = Phi()
        for free_var_0 in free_vars_0:
            phi0.set()
            vec_1 = phi0.phiEntry(None,vec_0)

            vec_0=[S.Zero]*self.cols 
            vec_0[free_var_0]=S.One 
            phi1 = Phi()
            for piv_row_4,piv_col_5 in enumerate(pivots_4):
                phi1.set()

                phi2 = Phi()
                for pos_0 in pivots_4[piv_row_4+1:]+(free_var_0,):
                    phi2.set()

                    vec_0[piv_col_5] = vec_0[piv_col_5]-reduced_3[piv_row_4,pos_0]
            basis_0.append(vec_0) 
        vec_2 = phi0.phiExit(None,vec_0)
        return [self._new(self.cols,1,b_1) for b_1 in basis_0]

    def rowspace(self,simplify=False):
        simplify_6 = simplify;
        reduced_4=None;pivots_5=None;

        """Returns a list of vectors that span the row space of self.""" 
        reduced_4,pivots_5=self.echelon_form(simplify=simplify_6,with_pivots_0=True) 
        return [reduced_4.row(i_31) for i_31 in range(len(pivots_5))]

    @classmethod
    def orthogonalize(cls,*vecs,**kwargs):
        vecs_0 = vecs;kwargs_0 = kwargs;
        ret_4=None;ret_5=None;ret_6=None;a_5=None;a_6=None;b_2=None;b_4=None;components_0=None;vec_3=None;normalize_1=None;perp_1=None;perp_0=None;perp_2=None;basis_1=None;

        """Apply the Gram-Schmidt orthogonalization procedure
        to vectors supplied in `vecs`.

        Arguments
        =========

        vecs : vectors to be made orthogonal
        normalize : bool. Whether the returned vectors
                    should be renormalized to be unit vectors.
        """ 
        normalize_1=kwargs_0.get('normalize',False) 
        def project(a,b):
            a_5 = a;b_2 = b;
            

            return b_2*(a_5.dot(b_2)/b_2.dot(b_2))

        def perp_to_subspace(vec,basis):
            vec_3 = vec;basis_1 = basis;
            a_6=None;components_0=None;b_4=None;

            """projects vec onto the subspace given
            by the orthogonal basis `basis`""" 
            components_0=[project(vec_3,b_3) for b_3 in basis_1] 
            if len(basis_1)==0:
                return vec_3
            return vec_3-reduce( lambda a_6 , b_4 :a_6+b_4,components_0)

        ret_4=[] 
        phi0 = Phi()
        while len(vecs_0)>0 and vecs_0[0].is_zero:
            phi0.set()

            del vecs_0[0]
        phi0 = Phi()
        for vec_9 in vecs_0:
            phi0.set()
            perp_1 = phi0.phiEntry(None,perp_0)

            perp_0=perp_to_subspace(vec_9,ret_4) 
            if  not perp_0.is_zero:
                ret_4.append(perp_0) 
        perp_2 = phi0.phiExit(None,perp_0)
        if normalize_1:
            ret_5=[vec_5/vec_5.norm() for vec_5 in ret_4] 
        phiPreds = [normalize_1]
        phiNames = [ret_5,ret_4]
        ret_6= phiIf(phiPreds, phiNames)
        return ret_6

class MatrixEigen(MatrixSubspaces):
    """Provides basic matrix eigenvalue/vector operations.
    Should not be instantiated directly.""" 
    _cache_is_diagonalizable= None  
    _cache_eigenvects= None  
    def diagonalize(self,reals_only=False,sort=False,normalize=False):
        reals_only_0 = reals_only;sort_0 = sort;normalize_2 = normalize;
        eigenvecs_0=None;eigenvecs_1=None;eigenvecs_2=None;eigenvecs_3=None;eigenvecs_4=None;diag_0=None;diag_2=None;diag_1=None;diag_3=None;p_cols_0=None;p_cols_2=None;p_cols_1=None;p_cols_3=None;p_cols_4=None;p_cols_5=None;

        """
        Return (P, D), where D is diagonal and

            D = P^-1 * M * P

        where M is current matrix.

        Parameters
        ==========

        reals_only : bool. Whether to throw an error if complex numbers are need
                     to diagonalize. (Default: False)
        sort : bool. Sort the eigenvalues along the diagonal. (Default: False)
        normalize : bool. If True, normalize the columns of P. (Default: False)

        Examples
        ========

        >>> from sympy import Matrix
        >>> m = Matrix(3, 3, [1, 2, 0, 0, 3, 0, 2, -4, 2])
        >>> m
        Matrix([
        [1,  2, 0],
        [0,  3, 0],
        [2, -4, 2]])
        >>> (P, D) = m.diagonalize()
        >>> D
        Matrix([
        [1, 0, 0],
        [0, 2, 0],
        [0, 0, 3]])
        >>> P
        Matrix([
        [-1, 0, -1],
        [ 0, 0, -1],
        [ 2, 1,  2]])
        >>> P.inv() * m * P
        Matrix([
        [1, 0, 0],
        [0, 2, 0],
        [0, 0, 3]])

        See Also
        ========

        is_diagonal
        is_diagonalizable
        """ 
        if  not self.is_square:
            raise NonSquareMatrixError()
        if  not self.is_diagonalizable(reals_only_0=reals_only_0,clear_cache=False):
            raise MatrixError("Matrix is not diagonalizable")
        eigenvecs_0=self._cache_eigenvects 
        if eigenvecs_0 is None:
            eigenvecs_1=self.eigenvects(simplify_6=True) 
        phiPreds = [eigenvecs_0 is None]
        phiNames = [eigenvecs_1,eigenvecs_0]
        eigenvecs_2= phiIf(phiPreds, phiNames)
        if sort_0:
            eigenvecs_3=sorted(eigenvecs_2,key=default_sort_key) 
        phiPreds = [sort_0]
        phiNames = [eigenvecs_3,eigenvecs_2]
        eigenvecs_4= phiIf(phiPreds, phiNames)
        p_cols_0,diag=[],[] 
        phi0 = Phi()
        for val_6,mult_0,basis_2 in eigenvecs_4:
            phi0.set()
            p_cols_2 = phi0.phiEntry(p_cols_0,p_cols_1)

            diag = diag+[val_6]*mult_0
            p_cols_1 = p_cols_2+basis_2
        p_cols_3 = phi0.phiExit(p_cols_0,p_cols_1)
        if normalize_2:
            p_cols_4=[v_0/v_0.norm() for v_0 in p_cols_3] 
        phiPreds = [normalize_2]
        phiNames = [p_cols_4,p_cols_3]
        p_cols_5= phiIf(phiPreds, phiNames)
        return self.hstack(*p_cols_5),self.diag(*diag)

    def eigenvals(self,error_when_incomplete=True,**flags):
        error_when_incomplete_0 = error_when_incomplete;flags_0 = flags;
        mat_4=None;mat_5=None;mat_6=None;mat_7=None;x_6=None;x_7=None;x_8=None;eigs_0=None;

        """Return eigenvalues using the Berkowitz agorithm to compute
        the characteristic polynomial.

        Parameters
        ==========

        error_when_incomplete : bool
            Raise an error when not all eigenvalues are computed. This is
            caused by ``roots`` not returning a full list of eigenvalues.

        Since the roots routine doesn't always work well with Floats,
        they will be replaced with Rationals before calling that
        routine. If this is not desired, set flag ``rational`` to False.
        """ 
        mat_4=self 
        if  not mat_4:
            return {}
        if flags_0.pop('rational',True):
            if any(v_1.has(Float) for v_1 in mat_4):
                mat_5=mat_4.applyfunc( lambda x_6 :nsimplify(x_6,rational=True)) 
            phiPreds = [any(v_1.has(Float) for v_1 in mat_4)]
            phiNames = [mat_5,mat_4]
            mat_6= phiIf(phiPreds, phiNames)
            phiPreds = [any(v_1.has(Float) for v_1 in mat_4)]
            phiNames = [x_6,None]
            x_7= phiIf(phiPreds, phiNames)
        phiPreds = [flags_0.pop('rational',True)]
        phiNames = [mat_6,mat_4]
        mat_7= phiIf(phiPreds, phiNames)
        phiPreds = [flags_0.pop('rational',True)]
        phiNames = [x_7,None]
        x_8= phiIf(phiPreds, phiNames)
        flags_0.pop('simplify',None) 
        eigs_0=roots(mat_7.charpoly(x=Dummy('x')),**flags_0) 
        if error_when_incomplete_0 and sum(m_0 for m_0 in eigs_0.values())!=self.cols:
            raise MatrixError("Could not compute eigenvalues for {}".format(self))
        return eigs_0

    def eigenvects(self,error_when_incomplete=True,**flags):
        error_when_incomplete_1 = error_when_incomplete;flags_1 = flags;
        ret_7=None;ret_8=None;ret_9=None;ret_10=None;ret_11=None;ret_12=None;ret_13=None;ret_14=None;mat_8=None;mat_9=None;mat_10=None;primitive_0=None;eigenvals_0=None;chop_0=None;l_0=None;l_1=None;simpfunc_7=None;simpfunc_8=None;m_1=None;has_floats_0=None;x_9=None;x_10=None;x_11=None;x_12=None;simplify_7=None;eigenval_0=None;

        """Return list of triples (eigenval, multiplicity, basis).

        The flag ``simplify`` has two effects:
            1) if bool(simplify) is True, as_content_primitive()
            will be used to tidy up normalization artifacts;
            2) if nullspace needs simplification to compute the
            basis, the simplify flag will be passed on to the
            nullspace routine which will interpret it there.

        Parameters
        ==========

        error_when_incomplete : bool
            Raise an error when not all eigenvalues are computed. This is
            caused by ``roots`` not returning a full list of eigenvalues.

        If the matrix contains any Floats, they will be changed to Rationals
        for computation purposes, but the answers will be returned after being
        evaluated with evalf. If it is desired to removed small imaginary
        portions during the evalf step, pass a value for the ``chop`` flag.
        """ 
        from sympy.matrices import eye
        simplify_7=flags_1.get('simplify',True) 
        if  not isinstance(simplify_7,FunctionType):
            simpfunc_7=_simplify if simplify_7 else  lambda x_9 :x_9 
        phiPreds = [ not isinstance(simplify_7,FunctionType)]
        phiNames = [x_9,None]
        x_10= phiIf(phiPreds, phiNames)
        phiPreds = [ not isinstance(simplify_7,FunctionType)]
        phiNames = [simpfunc_7,None]
        simpfunc_8= phiIf(phiPreds, phiNames)
        primitive_0=flags_1.get('simplify',False) 
        chop_0=flags_1.pop('chop',False) 
        flags_1.pop('multiple',None) 
        mat_8=self 
        has_floats_0=any(v_2.has(Float) for v_2 in self) 
        if has_floats_0:
            mat_9=mat_8.applyfunc( lambda x_11 :nsimplify(x_11,rational=True)) 
        phiPreds = [has_floats_0]
        phiNames = [mat_9,mat_8]
        mat_10= phiIf(phiPreds, phiNames)
        phiPreds = [has_floats_0]
        phiNames = [x_11,x_10]
        x_12= phiIf(phiPreds, phiNames)
        def eigenspace(eigenval):
            eigenval_0 = eigenval;
            ret_7=None;ret_8=None;ret_9=None;m_1=None;

            """Get a basis for the eigenspace for a particular eigenvalue""" 
            m_0=mat_10-self.eye(mat_10.rows)*eigenval_0 
            ret_7=m_0.nullspace() 
            if len(ret_7)==0 and simplify_7:
                ret_8=m_0.nullspace(simplify_7=True) 
            phiPreds = [len(ret_7)==0 and simplify_7]
            phiNames = [ret_8,ret_7]
            ret_9= phiIf(phiPreds, phiNames)
            if len(ret_9)==0:
                raise NotImplementedError("Can't evaluate eigenvector for eigenvalue %s"%eigenval_0)
            return ret_9

        eigenvals_0=mat_10.eigenvals(rational=False,error_when_incomplete=error_when_incomplete_1,**flags_1) 
        ret_10=[(val_7,mult_1,eigenspace(val_7)) for val_7,mult_1 in sorted(eigenvals_0.items(),key=default_sort_key)] 
        if primitive_0:
            def denom_clean(l):
                l_0 = l;
                

                from sympy import gcd
                return [(v_3/gcd(list(v_3))).applyfunc(simpfunc_8) for v_3 in l_0]

            ret_11=[(val_8,mult_2,denom_clean(es_0)) for val_8,mult_2,es_0 in ret_10] 
        phiPreds = [primitive_0]
        phiNames = [ret_11,ret_10]
        ret_12= phiIf(phiPreds, phiNames)
        phiPreds = [primitive_0]
        phiNames = [l_0,None]
        l_1= phiIf(phiPreds, phiNames)
        if has_floats_0:
            ret_13=[(val_9.evalf(chop=chop_0),mult_3,[v_4.evalf(chop=chop_0) for v_4 in es_1]) for val_9,mult_3,es_1 in ret_12] 
        phiPreds = [has_floats_0]
        phiNames = [ret_13,ret_12]
        ret_14= phiIf(phiPreds, phiNames)
        return ret_14

    def is_diagonalizable(self,reals_only=False,**kwargs):
        reals_only_1 = reals_only;kwargs_1 = kwargs;
        ret_15=None;ret_16=None;ret_17=None;ret_22=None;ret_18=None;ret_19=None;ret_20=None;ret_21=None;ret_23=None;clear_cache_0=None;clear_cache_1=None;clear_cache_2=None;

        """Returns true if a matrix is diagonalizable.

        Parameters
        ==========

        reals_only : bool. If reals_only=True, determine whether the matrix can be
                     diagonalized without complex numbers. (Default: False)

        kwargs
        ======

        clear_cache : bool. If True, clear the result of any computations when finished.
                      (Default: True)

        Examples
        ========

        >>> from sympy import Matrix
        >>> m = Matrix(3, 3, [1, 2, 0, 0, 3, 0, 2, -4, 2])
        >>> m
        Matrix([
        [1,  2, 0],
        [0,  3, 0],
        [2, -4, 2]])
        >>> m.is_diagonalizable()
        True
        >>> m = Matrix(2, 2, [0, 1, 0, 0])
        >>> m
        Matrix([
        [0, 1],
        [0, 0]])
        >>> m.is_diagonalizable()
        False
        >>> m = Matrix(2, 2, [0, 1, -1, 0])
        >>> m
        Matrix([
        [ 0, 1],
        [-1, 0]])
        >>> m.is_diagonalizable()
        True
        >>> m.is_diagonalizable(reals_only=True)
        False

        See Also
        ========

        is_diagonal
        diagonalize
        """ 
        clear_cache_0=kwargs_1.get('clear_cache',True) 
        if 'clear_subproducts' in kwargs_1:
            clear_cache_1=kwargs_1.get('clear_subproducts') 
        phiPreds = ['clear_subproducts' in kwargs_1]
        phiNames = [clear_cache_1,clear_cache_0]
        clear_cache_2= phiIf(phiPreds, phiNames)
        def cleanup():
            
            

            """Clears any cached values if requested""" 
            if clear_cache_2:
                self._cache_eigenvects= None  
                self._cache_is_diagonalizable= None  

        if  not self.is_square:
            cleanup() 
            return False
        if self._cache_is_diagonalizable is  not None:
            ret_15=self._cache_is_diagonalizable 
            cleanup() 
            return ret_15
        phiPreds = [self._cache_is_diagonalizable is  not None]
        phiNames = [ret_15,None]
        ret_16= phiIf(phiPreds, phiNames)
        if all(e_1.is_real for e_1 in self) and self.is_symmetric():
            self._cache_is_diagonalizable=True 
            cleanup() 
            return True
        self._cache_eigenvects=self.eigenvects(simplify_7=True) 
        ret_17=True 
        phi0 = Phi()
        for val_10,mult_4,basis_3 in self._cache_eigenvects:
            phi0.set()
            ret_22 = phi0.phiEntry(ret_17,ret_21)

            if reals_only_1 and  not val_10.is_real:
                ret_18=False 
            phiPreds = [reals_only_1 and  not val_10.is_real]
            phiNames = [ret_18,ret_22]
            ret_19= phiIf(phiPreds, phiNames)
            if mult_4!=len(basis_3):
                ret_20=False 
            phiPreds = [mult_4!=len(basis_3)]
            phiNames = [ret_20,ret_19]
            ret_21= phiIf(phiPreds, phiNames)
        ret_23 = phi0.phiExit(ret_17,ret_21)
        cleanup() 
        return ret_23

    def jordan_form(self,calc_transform=True,**kwargs):
        calc_transform_0 = calc_transform;kwargs_2 = kwargs;
        basis_mat_0=None;basis_mat_1=None;basis_mat_2=None;block_sizes_1=None;block_sizes_0=None;block_sizes_2=None;block_structure_0=None;new_vecs_3=None;new_vecs_1=None;new_vecs_0=None;new_vecs_2=None;new_vecs_4=None;mid_0=None;max_prec_0=None;max_prec_2=None;jordan_mat_0=None;jordan_mat_1=None;jordan_mat_2=None;has_floats_1=None;vec_9=None;vec_7=None;vec_6=None;vec_8=None;vec_10=None;null_small_3=None;null_small_1=None;null_small_0=None;null_small_2=None;null_small_4=None;max_dps_0=None;max_dps_1=None;pow_0=None;end_0=None;cols_7=None;val_11=None;val_12=None;ret_24=None;mat_11=None;mat_12=None;mat_13=None;big_basis_0=None;chain_1=None;chain_0=None;chain_2=None;d_1=None;mat_cache_0=None;blocks_0=None;blocks_1=None;blocks_2=None;chop_1=None;i_32=None;i_34=None;i_33=None;i_35=None;pivots_7=None;pivots_6=None;pivots_8=None;null_big_3=None;null_big_1=None;null_big_0=None;null_big_2=None;null_big_4=None;eig_basis_1=None;eig_basis_0=None;eig_basis_2=None;args_0=None;args_1=None;args_2=None;size_nums_1=None;size_nums_0=None;size_nums_2=None;jordan_basis_0=None;jordan_basis_1=None;jordan_basis_2=None;small_basis_0=None;x_13=None;x_14=None;nullity_0=None;nullity_2=None;nullity_1=None;nullity_3=None;eigs_1=None;

        """Return `(P, J)` where `J` is a Jordan block
        matrix and `P` is a matrix such that

            `self == P*J*P**-1`


        Parameters
        ==========

        calc_transform : bool
            If ``False``, then only `J` is returned.
        chop : bool
            All matrices are convered to exact types when computing
            eigenvalues and eigenvectors.  As a result, there may be
            approximation errors.  If ``chop==True``, these errors
            will be truncated.

        Examples
        ========

        >>> from sympy import Matrix
        >>> m = Matrix([[ 6,  5, -2, -3], [-3, -1,  3,  3], [ 2,  1, -2, -3], [-1,  1,  5,  5]])
        >>> P, J = m.jordan_form()
        >>> J
        Matrix([
        [2, 1, 0, 0],
        [0, 2, 0, 0],
        [0, 0, 2, 1],
        [0, 0, 0, 2]])

        See Also
        ========

        jordan_block
        """ 
        if  not self.is_square:
            raise NonSquareMatrixError("Only square matrices have Jordan forms")
        chop_1=kwargs_2.pop('chop',False) 
        mat_11=self 
        has_floats_1=any(v_5.has(Float) for v_5 in self) 
        if has_floats_1:
            try:
                max_prec_0=max(term_0._prec for term_0 in self._mat if isinstance(term_0,Float)) 
            except ValueError:
                max_prec_1=53 
            max_dps_0=max(prec_to_dps(max_prec_1),15) 
        phiPreds = [has_floats_1]
        phiNames = [max_dps_0,None]
        max_dps_1= phiIf(phiPreds, phiNames)
        phiPreds = [has_floats_1]
        phiNames = [max_prec_0,None]
        max_prec_2= phiIf(phiPreds, phiNames)
        def restore_floats(*args):
            args_0 = args;
            args_1=None;args_2=None;

            """If `has_floats` is `True`, cast all `args` as
            matrices of floats.""" 
            if has_floats_1:
                args_1=[m_2.evalf(prec=max_dps_1,chop=chop_1) for m_2 in args_0] 
            phiPreds = [has_floats_1]
            phiNames = [args_1,args_0]
            args_2= phiIf(phiPreds, phiNames)
            if len(args_2)==1:
                return args_2[0]
            return args_2

        mat_cache_0={} 
        def eig_mat(val,pow):
            val_11 = val;pow_0 = pow;
            

            """Cache computations of (self - val*I)**pow for quick
            retrieval""" 
            if (val_11,pow_0) in mat_cache_0:
                return mat_cache_0[(val_11,pow_0)]
            if (val_11,pow_0-1) in mat_cache_0:
                mat_cache_0[(val_11,pow_0)]=mat_cache_0[(val_11,pow_0-1)]*mat_cache_0[(val_11,1)] 
            else:
                mat_cache_0[(val_11,pow_0)]=(mat_11-val_11*self.eye(self.rows))**pow_0 
            return mat_cache_0[(val_11,pow_0)]

        def nullity_chain(val):
            val_12 = val;
            ret_24=None;i_32=None;i_34=None;i_33=None;i_35=None;cols_7=None;nullity_0=None;nullity_2=None;nullity_1=None;nullity_3=None;

            """Calculate the sequence  [0, nullity(E), nullity(E**2), ...]
            until it is constant where `E = self - val*I`""" 
            cols_7=self.cols 
            ret_24=[0] 
            nullity_0=cols_7-eig_mat(val_12,1).rank() 
            i_32=2 
            phi0 = Phi()
            while phi0.phiLoopTest(nullity_0,nullity_1)!=ret_24[-1]:
                phi0.set()
                i_34 = phi0.phiEntry(i_32,i_33)
                nullity_2 = phi0.phiEntry(nullity_0,nullity_1)

                ret_24.append(nullity_2) 
                nullity_1=cols_7-eig_mat(val_12,i_34).rank() 
                i_33 = i_34+1
            i_35 = phi0.phiExit(i_32,i_33)
            nullity_3 = phi0.phiExit(nullity_0,nullity_1)
            return ret_24

        def blocks_from_nullity_chain(d):
            d_1 = d;
            mid_0=None;end_0=None;

            """Return a list of the size of each Jordan block.
            If d_n is the nullity of E**n, then the number
            of Jordan blocks of size n is

                2*d_n - d_(n-1) - d_(n+1)""" 
            mid_0=[2*d_1[n_1]-d_1[n_1-1]-d_1[n_1+1] for n_1 in range(1,len(d_1)-1)] 
            end_0=[d_1[-1]-d_1[-2]] if len(d_1)>1 else [d_1[0]] 
            return mid_0+end_0

        def pick_vec(small_basis,big_basis):
            small_basis_0 = small_basis;big_basis_0 = big_basis;
            pivots_7=None;pivots_6=None;pivots_8=None;

            """Picks a vector from big_basis that isn't in
            the subspace spanned by small_basis""" 
            if len(small_basis_0)==0:
                return big_basis_0[0]
            phi0 = Phi()
            for v_1 in big_basis_0:
                phi0.set()
                pivots_7 = phi0.phiEntry(None,pivots_6)

                _,pivots_6=self.hstack(*(small_basis_0+[v_1])).echelon_form(with_pivots_0=True) 
                if pivots_6[-1]==len(small_basis_0):
                    return v_1
            pivots_8 = phi0.phiExit(None,pivots_6)

        if has_floats_1:
            mat_12=mat_11.applyfunc( lambda x_13 :nsimplify(x_13,rational=True)) 
        phiPreds = [has_floats_1]
        phiNames = [mat_12,mat_11]
        mat_13= phiIf(phiPreds, phiNames)
        phiPreds = [has_floats_1]
        phiNames = [x_13,None]
        x_14= phiIf(phiPreds, phiNames)
        eigs_1=mat_13.eigenvals() 
        if sum(m_3 for m_3 in eigs_1.values())!=mat_13.cols:
            raise MatrixError("Could not compute eigenvalues for {}".format(mat_13))
        if len(eigs_1.keys())==mat_13.cols:
            blocks_0=list(sorted(eigs_1.keys(),key=default_sort_key)) 
            jordan_mat_0=mat_13.diag(*blocks_0) 
            if  not calc_transform_0:
                return restore_floats(jordan_mat_0)
            jordan_basis_0=[eig_mat(eig_0,1).nullspace()[0] for eig_0 in blocks_0] 
            basis_mat_0=mat_13.hstack(*jordan_basis_0) 
            return restore_floats(basis_mat_0,jordan_mat_0)
        phiPreds = [len(eigs_1.keys())==mat_13.cols]
        phiNames = [basis_mat_0,None]
        basis_mat_1= phiIf(phiPreds, phiNames)
        phiPreds = [len(eigs_1.keys())==mat_13.cols]
        phiNames = [jordan_basis_0,None]
        jordan_basis_1= phiIf(phiPreds, phiNames)
        phiPreds = [len(eigs_1.keys())==mat_13.cols]
        phiNames = [blocks_0,None]
        blocks_1= phiIf(phiPreds, phiNames)
        phiPreds = [len(eigs_1.keys())==mat_13.cols]
        phiNames = [jordan_mat_0,None]
        jordan_mat_1= phiIf(phiPreds, phiNames)
        block_structure_0=[] 
        phi0 = Phi()
        for eig_1 in sorted(eigs_1.keys(),key=default_sort_key):
            phi0.set()
            chain_1 = phi0.phiEntry(None,chain_0)
            size_nums_1 = phi0.phiEntry(None,size_nums_0)
            block_sizes_1 = phi0.phiEntry(None,block_sizes_0)

            chain_0=nullity_chain(eig_1) 
            block_sizes_0=blocks_from_nullity_chain(chain_0) 
            size_nums_0=[(i_36+1,num_0) for i_36,num_0 in enumerate(block_sizes_0)] 
            size_nums_0.reverse() 
            block_structure_0.extend((eig_1,size_0) for size_0,num_1 in size_nums_0 for _ in range(num_1)) 
        chain_2 = phi0.phiExit(None,chain_0)
        size_nums_2 = phi0.phiExit(None,size_nums_0)
        block_sizes_2 = phi0.phiExit(None,block_sizes_0)
        blocks_2=(mat_13.jordan_block(size_1=size_1,eigenvalue=eig_2) for eig_2,size_1 in block_structure_0) 
        jordan_mat_2=mat_13.diag(*blocks_2) 
        if  not calc_transform_0:
            return restore_floats(jordan_mat_2)
        jordan_basis_2=[] 
        phi0 = Phi()
        for eig_3 in sorted(eigs_1.keys(),key=default_sort_key):
            phi0.set()
            vec_9 = phi0.phiEntry(vec_9,vec_8)
            null_small_3 = phi0.phiEntry(None,null_small_2)
            new_vecs_3 = phi0.phiEntry(None,new_vecs_2)
            null_big_3 = phi0.phiEntry(None,null_big_2)
            eig_basis_1 = phi0.phiEntry(None,eig_basis_0)

            eig_basis_0=[] 
            phi1 = Phi()
            for block_eig_0,size_2 in block_structure_0:
                phi1.set()
                vec_7 = phi1.phiEntry(vec_7,vec_6)
                null_small_1 = phi1.phiEntry(null_small_3,null_small_0)
                new_vecs_1 = phi1.phiEntry(new_vecs_3,new_vecs_0)
                null_big_1 = phi1.phiEntry(null_big_3,null_big_0)

                if block_eig_0!=eig_3:
                    continue
                null_big_0=(eig_mat(eig_3,size_2)).nullspace() 
                null_small_0=(eig_mat(eig_3,size_2-1)).nullspace() 
                vec_6=pick_vec(null_small_0+eig_basis_0,null_big_0) 
                new_vecs_0=[(eig_mat(eig_3,i_37))*vec_6 for i_37 in range(size_2)] 
                eig_basis_0.extend(new_vecs_0) 
                jordan_basis_2.extend(reversed(new_vecs_0)) 
            vec_8 = phi1.phiExit(None,vec_6)
            null_small_2 = phi1.phiExit(None,null_small_0)
            new_vecs_2 = phi1.phiExit(None,new_vecs_0)
            null_big_2 = phi1.phiExit(None,null_big_0)
        vec_10 = phi0.phiExit(None,vec_8)
        null_small_4 = phi0.phiExit(None,null_small_2)
        new_vecs_4 = phi0.phiExit(None,new_vecs_2)
        null_big_4 = phi0.phiExit(None,null_big_2)
        eig_basis_2 = phi0.phiExit(None,eig_basis_0)
        basis_mat_2=mat_13.hstack(*jordan_basis_2) 
        return restore_floats(basis_mat_2,jordan_mat_2)

    def left_eigenvects(self,**flags):
        flags_2 = flags;
        eigs_2=None;

        """Returns left eigenvectors and eigenvalues.

        This function returns the list of triples (eigenval, multiplicity,
        basis) for the left eigenvectors. Options are the same as for
        eigenvects(), i.e. the ``**flags`` arguments gets passed directly to
        eigenvects().

        Examples
        ========

        >>> from sympy import Matrix
        >>> M = Matrix([[0, 1, 1], [1, 0, 0], [1, 1, 1]])
        >>> M.eigenvects()
        [(-1, 1, [Matrix([
        [-1],
        [ 1],
        [ 0]])]), (0, 1, [Matrix([
        [ 0],
        [-1],
        [ 1]])]), (2, 1, [Matrix([
        [2/3],
        [1/3],
        [  1]])])]
        >>> M.left_eigenvects()
        [(-1, 1, [Matrix([[-2, 1, 1]])]), (0, 1, [Matrix([[-1, -1, 1]])]), (2,
        1, [Matrix([[1, 1, 1]])])]

        """ 
        eigs_2=self.transpose().eigenvects(**flags_2) 
        return [(val_13,mult_5,[l_2.transpose() for l_2 in basis_3]) for val_13,mult_5,basis_4 in eigs_2]

    def singular_values(self):
        
        mat_14=None;valmultpairs_0=None;vals_0=None;vals_2=None;vals_1=None;vals_3=None;

        """Compute the singular values of a Matrix

        Examples
        ========

        >>> from sympy import Matrix, Symbol
        >>> x = Symbol('x', real=True)
        >>> A = Matrix([[0, 1, 0], [0, x, 0], [-1, 0, 0]])
        >>> A.singular_values()
        [sqrt(x**2 + 1), 1, 0]

        See Also
        ========

        condition_number
        """ 
        mat_14=self 
        valmultpairs_0=(mat_14.H*mat_14).eigenvals() 
        vals_0=[] 
        phi0 = Phi()
        for k_12,v_6 in valmultpairs_0.items():
            phi0.set()
            vals_2 = phi0.phiEntry(vals_0,vals_1)

            vals_1 = vals_2+[sqrt(k_12)]*v_6
        vals_3 = phi0.phiExit(vals_0,vals_1)
        vals_3.sort(reverse=True,key=default_sort_key) 
        return vals_3

class MatrixCalculus(MatrixCommon):
    """Provides calculus-related matrix operations.""" 
    def diff(self,*args):
        args_3 = args;
        

        """Calculate the derivative of each element in the matrix.
        ``args`` will be passed to the ``integrate`` function.

        Examples
        ========

        >>> from sympy.matrices import Matrix
        >>> from sympy.abc import x, y
        >>> M = Matrix([[x, y], [1, 0]])
        >>> M.diff(x)
        Matrix([
        [1, 0],
        [0, 0]])

        See Also
        ========

        integrate
        limit
        """ 
        from sympy import Derivative
        return Derivative(self,*args_3,evaluate=True)

    def _eval_derivative(self,arg):
        arg_0 = arg;
        x_15=None;

        return self.applyfunc( lambda x_15 :x_15.diff(arg_0))

    def _accept_eval_derivative(self,s):
        s_0 = s;
        

        return s_0._visit_eval_derivative_array(self)

    def _visit_eval_derivative_scalar(self,base):
        base_0 = base;
        x_16=None;

        return self.applyfunc( lambda x_16 :base_0.diff(x_16))

    def _visit_eval_derivative_array(self,base):
        base_1 = base;
        

        from sympy import derive_by_array
        return derive_by_array(base_1,self)

    def integrate(self,*args):
        args_4 = args;
        x_17=None;

        """Integrate each element of the matrix.  ``args`` will
        be passed to the ``integrate`` function.

        Examples
        ========

        >>> from sympy.matrices import Matrix
        >>> from sympy.abc import x, y
        >>> M = Matrix([[x, y], [1, 0]])
        >>> M.integrate((x, ))
        Matrix([
        [x**2/2, x*y],
        [     x,   0]])
        >>> M.integrate((x, 0, 2))
        Matrix([
        [2, 2*y],
        [2,   0]])

        See Also
        ========

        limit
        diff
        """ 
        return self.applyfunc( lambda x_17 :x_17.integrate(*args_4))

    def jacobian(self,X):
        X_0 = X;
        X_1=None;X_2=None;i_38=None;j_21=None;m_4=None;m_5=None;m_6=None;n_2=None;n_3=None;n_4=None;

        """Calculates the Jacobian matrix (derivative of a vector-valued function).

        Parameters
        ==========

        self : vector of expressions representing functions f_i(x_1, ..., x_n).
        X : set of x_i's in order, it can be a list or a Matrix

        Both self and X can be a row or a column matrix in any order
        (i.e., jacobian() should always work).

        Examples
        ========

        >>> from sympy import sin, cos, Matrix
        >>> from sympy.abc import rho, phi
        >>> X = Matrix([rho*cos(phi), rho*sin(phi), rho**2])
        >>> Y = Matrix([rho, phi])
        >>> X.jacobian(Y)
        Matrix([
        [cos(phi), -rho*sin(phi)],
        [sin(phi),  rho*cos(phi)],
        [   2*rho,             0]])
        >>> X = Matrix([rho*cos(phi), rho*sin(phi)])
        >>> X.jacobian(Y)
        Matrix([
        [cos(phi), -rho*sin(phi)],
        [sin(phi),  rho*cos(phi)]])

        See Also
        ========

        hessian
        wronskian
        """ 
        if  not isinstance(X_0,MatrixBase):
            X_1=self._new(X_0) 
        phiPreds = [ not isinstance(X_0,MatrixBase)]
        phiNames = [X_1,X_0]
        X_2= phiIf(phiPreds, phiNames)
        if self.shape[0]==1:
            m_1=self.shape[1] 
        elif self.shape[1]==1:
            m_3=self.shape[0] 
        else:
            raise TypeError("self must be a row or a column matrix")
        phiPreds = [self.shape[0]==1,self.shape[1]==1]
        phiNames = [m_4,m_5,None]
        m_6= phiIf(phiPreds, phiNames)
        if X_2.shape[0]==1:
            n_2=X_2.shape[1] 
        elif X_2.shape[1]==1:
            n_3=X_2.shape[0] 
        else:
            raise TypeError("X must be a row or a column matrix")
        phiPreds = [X_2.shape[0]==1,X_2.shape[1]==1]
        phiNames = [n_2,n_3,None]
        n_4= phiIf(phiPreds, phiNames)
        return self._new(m_4,n_4, lambda j_21 , i_38 :self[j_21].diff(X_2[i_38]))

    def limit(self,*args):
        args_5 = args;
        x_18=None;

        """Calculate the limit of each element in the matrix.
        ``args`` will be passed to the ``limit`` function.

        Examples
        ========

        >>> from sympy.matrices import Matrix
        >>> from sympy.abc import x, y
        >>> M = Matrix([[x, y], [1, 0]])
        >>> M.limit(x, 2)
        Matrix([
        [2, y],
        [1, 0]])

        See Also
        ========

        integrate
        diff
        """ 
        return self.applyfunc( lambda x_18 :x_18.limit(*args_5))

class MatrixDeprecated(MatrixCommon):
    """A class to house deprecated matrix methods.""" 
    def berkowitz_charpoly(self,x=Dummy('lambda'),simplify=_simplify):
        x_19 = x;simplify_8 = simplify;
        

        return self.charpoly(x_19=x_19)

    def berkowitz_det(self):
        
        

        """Computes determinant using Berkowitz method.

        See Also
        ========

        det
        berkowitz
        """ 
        return self.det(method_9='berkowitz')

    def berkowitz_eigenvals(self,**flags):
        flags_3 = flags;
        

        """Computes eigenvalues of a Matrix using Berkowitz method.

        See Also
        ========

        berkowitz
        """ 
        return self.eigenvals(**flags_3)

    def berkowitz_minors(self):
        
        minors_0=None;sign_1=None;sign_3=None;sign_2=None;sign_4=None;

        """Computes principal minors using Berkowitz method.

        See Also
        ========

        berkowitz
        """ 
        sign_1,minors_0=S.One,[] 
        phi0 = Phi()
        for poly_0 in self.berkowitz():
            phi0.set()
            sign_3 = phi0.phiEntry(sign_1,sign_2)

            minors_0.append(sign_3*poly_0[-1]) 
            sign_2=-sign_3 
        sign_4 = phi0.phiExit(sign_1,sign_2)
        return tuple(minors_0)

    def berkowitz(self):
        
        A_1=None;A_3=None;A_2=None;A_4=None;a_8=None;a_7=None;a_9=None;berk_0=None;R_2=None;R_1=None;R_3=None;C_2=None;C_1=None;C_3=None;T_1=None;T_0=None;T_2=None;transforms_0=None;polys_0=None;k_12=None;k_11=None;k_13=None;items_2=None;items_0=None;items_1=None;items_3=None;N_0=None;

        from sympy.matrices import zeros
        berk_0=((1,),) 
        if  not self:
            return berk_0
        if  not self.is_square:
            raise NonSquareMatrixError()
        A_1,N_0=self,self.rows 
        transforms_0=[0]*(N_0-1) 
        phi0 = Phi()
        for n_5 in range(N_0,1,-1):
            phi0.set()
            A_3 = phi0.phiEntry(A_1,A_2)
            a_8 = phi0.phiEntry(None,a_7)
            R_2 = phi0.phiEntry(None,R_1)
            C_2 = phi0.phiEntry(None,C_1)
            T_1 = phi0.phiEntry(None,T_0)
            k_12 = phi0.phiEntry(k_12,k_11)
            items_2 = phi0.phiEntry(None,items_1)

            T_0,k_11=zeros(n_5+1,n_5),n_5-1 
            R_1,C_1=-A_3[k_11,:k_11],A_3[:k_11,k_11] 
            A_2,a_7=A_3[:k_11,:k_11],-A_3[k_11,k_11] 
            items_0=[C_1] 
            phi1 = Phi()
            for i_39 in range(0,n_5-2):
                phi1.set()

                items_0.append(A_2*items_0[i_39]) 
            phi1 = Phi()
            for i_40,B_0 in enumerate(items_0):
                phi1.set()

                items_0[i_40]=(R_1*B_0)[0,0] 
            items_1=[S.One,a_7]+items_0 
            phi1 = Phi()
            for i_41 in range(n_5):
                phi1.set()

                T_0[i_41:,i_41]=items_1[:n_5-i_41+1] 
            transforms_0[k_11-1]=T_0 
        A_4 = phi0.phiExit(A_1,A_2)
        a_9 = phi0.phiExit(None,a_7)
        R_3 = phi0.phiExit(None,R_1)
        C_3 = phi0.phiExit(None,C_1)
        T_2 = phi0.phiExit(None,T_0)
        k_13 = phi0.phiExit(None,k_11)
        items_3 = phi0.phiExit(None,items_1)
        polys_0=[self._new([S.One,-A_4[0,0]])] 
        phi0 = Phi()
        for i_42,T_3 in enumerate(transforms_0):
            phi0.set()

            polys_0.append(T_3*polys_0[i_42]) 
        return berk_0+tuple(map(tuple,polys_0))

    def cofactorMatrix(self,method="berkowitz"):
        method_10 = method;
        

        return self.cofactor_matrix(method_10=method_10)

    def det_bareis(self):
        
        

        return self.det(method_10='bareiss')

    def det_bareiss(self):
        
        

        """Compute matrix determinant using Bareiss' fraction-free
        algorithm which is an extension of the well known Gaussian
        elimination method. This approach is best suited for dense
        symbolic matrices and will result in a determinant with
        minimal number of fractions. It means that less term
        rewriting is needed on resulting formulae.

        TODO: Implement algorithm for sparse matrices (SFF),
        http://www.eecis.udel.edu/~saunders/papers/sffge/it5.ps.

        See Also
        ========

        det
        berkowitz_det
        """ 
        return self.det(method_10='bareiss')

    def det_LU_decomposition(self):
        
        

        """Compute matrix determinant using LU decomposition


        Note that this method fails if the LU decomposition itself
        fails. In particular, if the matrix has no inverse this method
        will fail.

        TODO: Implement algorithm for sparse matrices (SFF),
        http://www.eecis.udel.edu/~saunders/papers/sffge/it5.ps.

        See Also
        ========


        det
        det_bareiss
        berkowitz_det
        """ 
        return self.det(method_10='lu')

    def jordan_cell(self,eigenval,n):
        eigenval_1 = eigenval;n_6 = n;
        

        return self.jordan_block(size_2=n_6,eigenvalue=eigenval_1)

    def jordan_cells(self,calc_transformation=True):
        calc_transformation_0 = calc_transformation;
        P_0=None;J_0=None;

        P_0,J_0=self.jordan_form() 
        return P_0,J_0.get_diag_blocks()

    def minorEntry(self,i,j,method="berkowitz"):
        i_43 = i;j_22 = j;method_11 = method;
        

        return self.minor(i_43,j_22,method_11=method_11)

    def minorMatrix(self,i,j):
        i_44 = i;j_23 = j;
        

        return self.minor_submatrix(i_44,j_23)

    def permuteBkwd(self,perm):
        perm_1 = perm;
        

        """Permute the rows of the matrix with the given permutation in reverse.""" 
        return self.permute_rows(perm_1,direction='backward')

    def permuteFwd(self,perm):
        perm_2 = perm;
        

        """Permute the rows of the matrix with the given permutation.""" 
        return self.permute_rows(perm_2,direction='forward')

class MatrixBase(MatrixDeprecated,MatrixCalculus,MatrixEigen,MatrixCommon):
    """Base class for matrix objects.""" 
    __array_priority__=11 
    is_Matrix=True 
    _class_priority=3 
    _sympify=staticmethod(sympify) 
    __hash__= None  
    def __array__(self):
        
        

        from .dense import matrix2numpy
        return matrix2numpy(self)

    def __getattr__(self,attr):
        attr_0 = attr;
        args_6=None;args_7=None;item_0=None;item_1=None;item_doit_0=None;item_doit_1=None;

        if attr_0 in ('diff','integrate','limit'):
            def doit(*args):
                args_6 = args;
                item_0=None;item_doit_0=None;

                item_doit_0= lambda item_0 :getattr(item_0,attr_0)(*args_6) 
                return self.applyfunc(item_doit_0)

            return doit
        else:
            raise AttributeError("%s has no attribute %s."%(self.__class__.__name__,attr_0))
        phiPreds = [attr_0 in ('diff','integrate','limit')]
        phiNames = [args_6,None]
        args_7= phiIf(phiPreds, phiNames)
        phiPreds = [attr_0 in ('diff','integrate','limit')]
        phiNames = [item_0,None]
        item_1= phiIf(phiPreds, phiNames)
        phiPreds = [attr_0 in ('diff','integrate','limit')]
        phiNames = [item_doit_0,None]
        item_doit_1= phiIf(phiPreds, phiNames)

    def __len__(self):
        
        

        """Return the number of elements of self.

        Implemented mainly so bool(Matrix()) == False.
        """ 
        return self.rows*self.cols

    def __mathml__(self):
        
        mml_0=None;mml_6=None;mml_1=None;mml_3=None;mml_2=None;mml_4=None;mml_5=None;mml_7=None;

        mml_0="" 
        phi0 = Phi()
        for i_45 in range(self.rows):
            phi0.set()
            mml_6 = phi0.phiEntry(mml_0,mml_5)

            mml_1 = mml_6+"<matrixrow>"
            phi1 = Phi()
            for j_24 in range(self.cols):
                phi1.set()
                mml_3 = phi1.phiEntry(mml_1,mml_2)

                mml_2 = mml_3+self[i_45,j_24].__mathml__()
            mml_4 = phi1.phiExit(mml_1,mml_2)
            mml_5 = mml_4+"</matrixrow>"
        mml_7 = phi0.phiExit(mml_0,mml_5)
        return "<matrix>"+mml_7+"</matrix>"

    def __ne__(self,other):
        other_0 = other;
        

        return  not self==other_0

    def _matrix_pow_by_jordan_blocks(self,num):
        num_2 = num;
        P_1=None;jordan_cells_0=None;jordan_cells_1=None;jc_0=None;J_1=None;l_3=None;bn_5=None;bn_3=None;bn_0=None;bn_1=None;bn_2=None;bn_4=None;bn_6=None;n_7=None;N_1=None;

        from sympy.matrices import diag,MutableMatrix
        from sympy import binomial
        def jordan_cell_power(jc,n):
            jc_0 = jc;n_7 = n;
            l_3=None;bn_5=None;bn_3=None;bn_0=None;bn_1=None;bn_2=None;bn_4=None;bn_6=None;N_1=None;

            N_1=jc_0.shape[0] 
            l_3=jc_0[0,0] 
            if l_3==0 and (n_7<N_1-1)!=False:
                raise ValueError("Matrix det == 0; not invertible")
            elif l_3==0 and N_1>1 and n_7%1!=0:
                raise ValueError("Non-integer power cannot be evaluated")
            phi0 = Phi()
            for i_46 in range(N_1):
                phi0.set()
                bn_5 = phi0.phiEntry(None,bn_4)

                phi1 = Phi()
                for j_25 in range(N_1-i_46):
                    phi1.set()
                    bn_3 = phi1.phiEntry(bn_5,bn_2)

                    bn_0=binomial(n_7,i_46) 
                    if isinstance(bn_0,binomial):
                        bn_1=bn_0._eval_expand_func() 
                    phiPreds = [isinstance(bn_0,binomial)]
                    phiNames = [bn_1,bn_0]
                    bn_2= phiIf(phiPreds, phiNames)
                    jc_0[j_25,i_46+j_25]=l_3**(n_7-i_46)*bn_2 
                bn_4 = phi1.phiExit(None,bn_2)
            bn_6 = phi0.phiExit(None,bn_4)

        P_1,J_1=self.jordan_form() 
        jordan_cells_0=J_1.get_diag_blocks() 
        jordan_cells_1=[MutableMatrix(j_26) for j_26 in jordan_cells_0] 
        phi0 = Phi()
        for j_27 in jordan_cells_1:
            phi0.set()

            jordan_cell_power(j_27,num_2) 
        return self._new(P_1*diag(*jordan_cells_1)*P_1.inv())

    def __repr__(self):
        
        

        return sstr(self)

    def __str__(self):
        
        

        if self.rows==0 or self.cols==0:
            return 'Matrix(%s, %s, [])'%(self.rows,self.cols)
        return "Matrix(%s)"%str(self.tolist())

    def _diagonalize_clear_subproducts(self):
        
        

        del self._is_symbolic
        del self._is_symmetric
        del self._eigenvects

    def _format_str(self,printer=None):
        printer_0 = printer;
        printer_1=None;printer_2=None;

        if  not printer_0:
            from sympy.printing.str import StrPrinter
            printer_1=StrPrinter() 
        phiPreds = [ not printer_0]
        phiNames = [printer_1,printer_0]
        printer_2= phiIf(phiPreds, phiNames)
        if self.rows==0 or self.cols==0:
            return 'Matrix(%s, %s, [])'%(self.rows,self.cols)
        if self.rows==1:
            return "Matrix([%s])"%self.table(printer_2,rowsep=',\n')
        return "Matrix([\n%s])"%self.table(printer_2,rowsep=',\n')

    @classmethod
    def _handle_creation_inputs(cls,*args,**kwargs):
        args_8 = args;kwargs_3 = kwargs;
        arr_0=None;arr_1=None;arr_2=None;in_mat_0=None;in_mat_1=None;in_mat_2=None;ncol_0=None;ncol_1=None;ncol_2=None;op_5=None;op_6=None;op_7=None;flat_list_0=None;flat_list_1=None;flat_list_2=None;flat_list_3=None;flat_list_4=None;flat_list_5=None;flat_list_6=None;flat_list_7=None;flat_list_8=None;flat_list_9=None;flat_list_10=None;flat_list_11=None;flat_list_12=None;flat_list_13=None;flat_list_14=None;rows_3=None;rows_4=None;rows_5=None;rows_6=None;rows_7=None;rows_8=None;rows_9=None;rows_10=None;cols_8=None;cols_9=None;cols_10=None;cols_11=None;cols_12=None;cols_13=None;cols_14=None;cols_15=None;cols_16=None;cols_17=None;cols_18=None;

        """Return the number of rows, cols and flat matrix elements.

        Examples
        ========

        >>> from sympy import Matrix, I

        Matrix can be constructed as follows:

        * from a nested list of iterables

        >>> Matrix( ((1, 2+I), (3, 4)) )
        Matrix([
        [1, 2 + I],
        [3,     4]])

        * from un-nested iterable (interpreted as a column)

        >>> Matrix( [1, 2] )
        Matrix([
        [1],
        [2]])

        * from un-nested iterable with dimensions

        >>> Matrix(1, 2, [1, 2] )
        Matrix([[1, 2]])

        * from no arguments (a 0 x 0 matrix)

        >>> Matrix()
        Matrix(0, 0, [])

        * from a rule

        >>> Matrix(2, 2, lambda i, j: i/(j + 1) )
        Matrix([
        [0,   0],
        [1, 1/2]])

        """ 
        from sympy.matrices.sparse import SparseMatrix
        flat_list_0= None  
        if len(args_8)==1:
            if isinstance(args_8[0],SparseMatrix):
                return args_8[0].rows,args_8[0].cols,flatten(args_8[0].tolist())
            elif isinstance(args_8[0],MatrixBase):
                return args_8[0].rows,args_8[0].cols,args_8[0]._mat
            elif isinstance(args_8[0],Basic) and args_8[0].is_Matrix:
                return args_8[0].rows,args_8[0].cols,args_8[0].as_explicit()._mat
            elif hasattr(args_8[0],"__array__"):
                arr_0=args_8[0].__array__() 
                if len(arr_0.shape)==2:
                    rows_3,cols_8=arr_0.shape[0],arr_0.shape[1] 
                    flat_list_1=[cls._sympify(i_47) for i_47 in arr_0.ravel()] 
                    return rows_3,cols_8,flat_list_1
                elif len(arr_0.shape)==1:
                    rows_4,cols_9=arr_0.shape[0],1 
                    flat_list_2=[S.Zero]*rows_4 
                    phi0 = Phi()
                    for i_48 in range(len(arr_0)):
                        phi0.set()

                        flat_list_2[i_48]=cls._sympify(arr_0[i_48]) 
                    return rows_4,cols_9,flat_list_2
                else:
                    raise NotImplementedError("SymPy supports just 1D and 2D matrices")
                phiPreds = [len(arr_0.shape)==2,len(arr_0.shape)==1]
                phiNames = [flat_list_1,flat_list_2,flat_list_0]
                flat_list_3= phiIf(phiPreds, phiNames)
                phiPreds = [len(arr_0.shape)==2,len(arr_0.shape)==1]
                phiNames = [rows_3,rows_4,None]
                rows_5= phiIf(phiPreds, phiNames)
                phiPreds = [len(arr_0.shape)==2,len(arr_0.shape)==1]
                phiNames = [cols_8,cols_9,None]
                cols_10= phiIf(phiPreds, phiNames)
            elif is_sequence(args_8[0]) and  not isinstance(args_8[0],DeferredVector):
                in_mat_0=[] 
                ncol_0=set() 
                phi0 = Phi()
                for row_5 in args_8[0]:
                    phi0.set()

                    if isinstance(row_5,MatrixBase):
                        in_mat_0.extend(row_5.tolist()) 
                        if row_5.cols or row_5.rows:
                            ncol_0.add(row_5.cols) 
                    else:
                        in_mat_0.append(row_5) 
                        try:
                            ncol_0.add(len(row_5)) 
                        except TypeError:
                            ncol_0.add(1) 
                if len(ncol_0)>1:
                    raise ValueError("Got rows of variable lengths: %s"%sorted(list(ncol_0)))
                cols_11=ncol_0.pop() if ncol_0 else 0 
                rows_6=len(in_mat_0) if cols_11 else 0 
                if rows_6:
                    if  not is_sequence(in_mat_0[0]):
                        cols_12=1 
                        flat_list_4=[cls._sympify(i_49) for i_49 in in_mat_0] 
                        return rows_6,cols_12,flat_list_4
                    phiPreds = [ not is_sequence(in_mat_0[0])]
                    phiNames = [flat_list_4,flat_list_0]
                    flat_list_5= phiIf(phiPreds, phiNames)
                    phiPreds = [ not is_sequence(in_mat_0[0])]
                    phiNames = [cols_12,cols_11]
                    cols_13= phiIf(phiPreds, phiNames)
                phiPreds = [rows_6]
                phiNames = [flat_list_5,flat_list_0]
                flat_list_6= phiIf(phiPreds, phiNames)
                phiPreds = [rows_6]
                phiNames = [cols_13,cols_11]
                cols_14= phiIf(phiPreds, phiNames)
                flat_list_7=[] 
                phi0 = Phi()
                for j_28 in range(rows_6):
                    phi0.set()

                    phi1 = Phi()
                    for i_50 in range(cols_14):
                        phi1.set()

                        flat_list_7.append(cls._sympify(in_mat_0[j_28][i_50])) 
            phiPreds = [isinstance(args_8[0],SparseMatrix),isinstance(args_8[0],MatrixBase),isinstance(args_8[0],Basic) and args_8[0].is_Matrix,hasattr(args_8[0],"__array__"),is_sequence(args_8[0]) and  not isinstance(args_8[0],DeferredVector)]
            phiNames = [None,None,None,arr_0,None,None]
            arr_1= phiIf(phiPreds, phiNames)
            phiPreds = [isinstance(args_8[0],SparseMatrix),isinstance(args_8[0],MatrixBase),isinstance(args_8[0],Basic) and args_8[0].is_Matrix,hasattr(args_8[0],"__array__"),is_sequence(args_8[0]) and  not isinstance(args_8[0],DeferredVector)]
            phiNames = [None,None,None,None,in_mat_0,None]
            in_mat_1= phiIf(phiPreds, phiNames)
            phiPreds = [isinstance(args_8[0],SparseMatrix),isinstance(args_8[0],MatrixBase),isinstance(args_8[0],Basic) and args_8[0].is_Matrix,hasattr(args_8[0],"__array__"),is_sequence(args_8[0]) and  not isinstance(args_8[0],DeferredVector)]
            phiNames = [None,None,None,None,ncol_0,None]
            ncol_1= phiIf(phiPreds, phiNames)
            phiPreds = [isinstance(args_8[0],SparseMatrix),isinstance(args_8[0],MatrixBase),isinstance(args_8[0],Basic) and args_8[0].is_Matrix,hasattr(args_8[0],"__array__"),is_sequence(args_8[0]) and  not isinstance(args_8[0],DeferredVector)]
            phiNames = [flat_list_0,flat_list_0,flat_list_0,flat_list_3,flat_list_7,flat_list_0]
            flat_list_8= phiIf(phiPreds, phiNames)
            phiPreds = [isinstance(args_8[0],SparseMatrix),isinstance(args_8[0],MatrixBase),isinstance(args_8[0],Basic) and args_8[0].is_Matrix,hasattr(args_8[0],"__array__"),is_sequence(args_8[0]) and  not isinstance(args_8[0],DeferredVector)]
            phiNames = [None,None,None,rows_5,rows_6,None]
            rows_7= phiIf(phiPreds, phiNames)
            phiPreds = [isinstance(args_8[0],SparseMatrix),isinstance(args_8[0],MatrixBase),isinstance(args_8[0],Basic) and args_8[0].is_Matrix,hasattr(args_8[0],"__array__"),is_sequence(args_8[0]) and  not isinstance(args_8[0],DeferredVector)]
            phiNames = [None,None,None,cols_10,cols_14,None]
            cols_15= phiIf(phiPreds, phiNames)
        elif len(args_8)==3:
            rows_8=as_int(args_8[0]) 
            cols_16=as_int(args_8[1]) 
            if rows_8<0 or cols_16<0:
                raise ValueError("Cannot create a {} x {} matrix. ""Both dimensions must be positive".format(rows_8,cols_16))
            if len(args_8)==3 and isinstance(args_8[2],collections.Callable):
                op_5=args_8[2] 
                flat_list_9=[] 
                phi0 = Phi()
                for i_51 in range(rows_8):
                    phi0.set()

                    flat_list_9.extend([cls._sympify(op_5(cls._sympify(i_51),cls._sympify(j_29))) for j_29 in range(cols_16)]) 
            elif len(args_8)==3 and is_sequence(args_8[2]):
                flat_list_10=args_8[2] 
                if len(flat_list_10)!=rows_8*cols_16:
                    raise ValueError('List length should be equal to rows*columns')
                flat_list_11=[cls._sympify(i_52) for i_52 in flat_list_10] 
            phiPreds = [len(args_8)==3 and isinstance(args_8[2],collections.Callable),len(args_8)==3 and is_sequence(args_8[2])]
            phiNames = [op_5,None,None]
            op_6= phiIf(phiPreds, phiNames)
            phiPreds = [len(args_8)==3 and isinstance(args_8[2],collections.Callable),len(args_8)==3 and is_sequence(args_8[2])]
            phiNames = [flat_list_9,flat_list_11,flat_list_0]
            flat_list_12= phiIf(phiPreds, phiNames)
        elif len(args_8)==0:
            rows_9=cols_17=0 
            flat_list_13=[] 
        phiPreds = [len(args_8)==1,len(args_8)==3,len(args_8)==0]
        phiNames = [arr_1,None,None,None]
        arr_2= phiIf(phiPreds, phiNames)
        phiPreds = [len(args_8)==1,len(args_8)==3,len(args_8)==0]
        phiNames = [in_mat_1,None,None,None]
        in_mat_2= phiIf(phiPreds, phiNames)
        phiPreds = [len(args_8)==1,len(args_8)==3,len(args_8)==0]
        phiNames = [ncol_1,None,None,None]
        ncol_2= phiIf(phiPreds, phiNames)
        phiPreds = [len(args_8)==1,len(args_8)==3,len(args_8)==0]
        phiNames = [None,op_6,None,None]
        op_7= phiIf(phiPreds, phiNames)
        phiPreds = [len(args_8)==1,len(args_8)==3,len(args_8)==0]
        phiNames = [flat_list_8,flat_list_12,flat_list_13,flat_list_0]
        flat_list_14= phiIf(phiPreds, phiNames)
        phiPreds = [len(args_8)==1,len(args_8)==3,len(args_8)==0]
        phiNames = [rows_7,rows_8,rows_9,None]
        rows_10= phiIf(phiPreds, phiNames)
        phiPreds = [len(args_8)==1,len(args_8)==3,len(args_8)==0]
        phiNames = [cols_15,cols_16,cols_17,None]
        cols_18= phiIf(phiPreds, phiNames)
        if flat_list_14 is None:
            raise TypeError("Data type not understood")
        return rows_10,cols_18,flat_list_14

    def _setitem(self,key,value):
        key_0 = key;value_0 = value;
        is_mat_0=None;is_mat_1=None;is_mat_2=None;is_mat_3=None;is_slice_0=None;i_53=None;j_30=None;value_1=None;value_2=None;value_3=None;key_1=None;key_2=None;key_3=None;key_4=None;key_5=None;key_6=None;

        """Helper to set value at location given by key.

        Examples
        ========

        >>> from sympy import Matrix, I, zeros, ones
        >>> m = Matrix(((1, 2+I), (3, 4)))
        >>> m
        Matrix([
        [1, 2 + I],
        [3,     4]])
        >>> m[1, 0] = 9
        >>> m
        Matrix([
        [1, 2 + I],
        [9,     4]])
        >>> m[1, 0] = [[0, 1]]

        To replace row r you assign to position r*m where m
        is the number of columns:

        >>> M = zeros(4)
        >>> m = M.cols
        >>> M[3*m] = ones(1, m)*2; M
        Matrix([
        [0, 0, 0, 0],
        [0, 0, 0, 0],
        [0, 0, 0, 0],
        [2, 2, 2, 2]])

        And to replace column c you can assign to position c:

        >>> M[2] = ones(m, 1)*4; M
        Matrix([
        [0, 0, 4, 0],
        [0, 0, 4, 0],
        [0, 0, 4, 0],
        [2, 2, 4, 2]])
        """ 
        from .dense import Matrix
        is_slice_0=isinstance(key_0,slice) 
        i_53,j_30=key_1=self.key2ij(key_0) 
        is_mat_0=isinstance(value_0,MatrixBase) 
        if type(i_53) is slice or type(j_30) is slice:
            if is_mat_0:
                self.copyin_matrix(key_1,value_0) 
                return 
            if  not isinstance(value_0,Expr) and is_sequence(value_0):
                self.copyin_list(key_1,value_0) 
                return 
            raise ValueError('unexpected value: %s'%value_0)
        else:
            if ( not is_mat_0 and  not isinstance(value_0,Basic) and is_sequence(value_0)):
                value_1=Matrix(value_0) 
                is_mat_1=True 
            phiPreds = [( not is_mat_0 and  not isinstance(value_0,Basic) and is_sequence(value_0))]
            phiNames = [is_mat_1,is_mat_0]
            is_mat_2= phiIf(phiPreds, phiNames)
            phiPreds = [( not is_mat_0 and  not isinstance(value_0,Basic) and is_sequence(value_0))]
            phiNames = [value_1,value_0]
            value_2= phiIf(phiPreds, phiNames)
            if is_mat_2:
                if is_slice_0:
                    key_2=(slice(*divmod(i_53,self.cols)),slice(*divmod(j_30,self.cols))) 
                else:
                    key_3=(slice(i_53,i_53+value_2.rows),slice(j_30,j_30+value_2.cols)) 
                phiPreds = [is_slice_0]
                phiNames = [key_2,key_3]
                key_4= phiIf(phiPreds, phiNames)
                self.copyin_matrix(key_4,value_2) 
            else:
                return i_53,j_30,self._sympify(value_2)
            phiPreds = [is_mat_2]
            phiNames = [key_4,key_1]
            key_5= phiIf(phiPreds, phiNames)
            return 
        phiPreds = [type(i_53) is slice or type(j_30) is slice]
        phiNames = [is_mat_0,is_mat_2]
        is_mat_3= phiIf(phiPreds, phiNames)
        phiPreds = [type(i_53) is slice or type(j_30) is slice]
        phiNames = [value_0,value_2]
        value_3= phiIf(phiPreds, phiNames)
        phiPreds = [type(i_53) is slice or type(j_30) is slice]
        phiNames = [key_1,key_5]
        key_6= phiIf(phiPreds, phiNames)

    def add(self,b):
        b_5 = b;
        

        """Return self + b """ 
        return self+b_5

    def cholesky_solve(self,rhs):
        rhs_0 = rhs;
        Y_0=None;rhs_1=None;rhs_2=None;L_0=None;L_1=None;L_2=None;

        """Solves Ax = B using Cholesky decomposition,
        for a general square non-singular matrix.
        For a non-square matrix with rows > cols,
        the least squares solution is returned.

        See Also
        ========

        lower_triangular_solve
        upper_triangular_solve
        gauss_jordan_solve
        diagonal_solve
        LDLsolve
        LUsolve
        QRsolve
        pinv_solve
        """ 
        if self.is_symmetric():
            L_0=self._cholesky() 
        elif self.rows>=self.cols:
            L_1=(self.T*self)._cholesky() 
            rhs_1=self.T*rhs_0 
        else:
            raise NotImplementedError('Under-determined System. ''Try M.gauss_jordan_solve(rhs)')
        phiPreds = [self.is_symmetric(),self.rows>=self.cols]
        phiNames = [L_0,L_1,None]
        L_2= phiIf(phiPreds, phiNames)
        phiPreds = [self.is_symmetric(),self.rows>=self.cols]
        phiNames = [rhs_0,rhs_1,rhs_0]
        rhs_2= phiIf(phiPreds, phiNames)
        Y_0=L_2._lower_triangular_solve(rhs_2) 
        return (L_2.T)._upper_triangular_solve(Y_0)

    def cholesky(self):
        
        

        """Returns the Cholesky decomposition L of a matrix A
        such that L * L.T = A

        A must be a square, symmetric, positive-definite
        and non-singular matrix.

        Examples
        ========

        >>> from sympy.matrices import Matrix
        >>> A = Matrix(((25, 15, -5), (15, 18, 0), (-5, 0, 11)))
        >>> A.cholesky()
        Matrix([
        [ 5, 0, 0],
        [ 3, 3, 0],
        [-1, 1, 3]])
        >>> A.cholesky() * A.cholesky().T
        Matrix([
        [25, 15, -5],
        [15, 18,  0],
        [-5,  0, 11]])

        See Also
        ========

        LDLdecomposition
        LUdecomposition
        QRdecomposition
        """ 
        if  not self.is_square:
            raise NonSquareMatrixError("Matrix must be square.")
        if  not self.is_symmetric():
            raise ValueError("Matrix must be symmetric.")
        return self._cholesky()

    def condition_number(self):
        
        singularvalues_0=None;

        """Returns the condition number of a matrix.

        This is the maximum singular value divided by the minimum singular value

        Examples
        ========

        >>> from sympy import Matrix, S
        >>> A = Matrix([[1, 0, 0], [0, 10, 0], [0, 0, S.One/10]])
        >>> A.condition_number()
        100

        See Also
        ========

        singular_values
        """ 
        if  not self:
            return S.Zero
        singularvalues_0=self.singular_values() 
        return Max(*singularvalues_0)/Min(*singularvalues_0)

    def copy(self):
        
        

        """
        Returns the copy of a matrix.

        Examples
        ========

        >>> from sympy import Matrix
        >>> A = Matrix(2, 2, [1, 2, 3, 4])
        >>> A.copy()
        Matrix([
        [1, 2],
        [3, 4]])

        """ 
        return self._new(self.rows,self.cols,self._mat)

    def cross(self,b):
        b_6 = b;
        

        r"""
        Return the cross product of ``self`` and ``b`` relaxing the condition
        of compatible dimensions: if each has 3 elements, a matrix of the
        same type and shape as ``self`` will be returned. If ``b`` has the same
        shape as ``self`` then common identities for the cross product (like
        `a \times b = - b \times a`) will hold.

        Parameters
        ==========
            b : 3x1 or 1x3 Matrix

        See Also
        ========

        dot
        multiply
        multiply_elementwise
        """ 
        if  not is_sequence(b_6):
            raise TypeError("`b` must be an ordered iterable or Matrix, not %s."%type(b_6))
        if  not (self.rows*self.cols==b_6.rows*b_6.cols==3):
            raise ShapeError("Dimensions incorrect for cross product: %s x %s"%((self.rows,self.cols),(b_6.rows,b_6.cols)))
        else:
            return self._new(self.rows,self.cols,((self[1]*b_6[2]-self[2]*b_6[1]),(self[2]*b_6[0]-self[0]*b_6[2]),(self[0]*b_6[1]-self[1]*b_6[0])))

    @property
    def D(self):
        
        

        """Return Dirac conjugate (if self.rows == 4).

        Examples
        ========

        >>> from sympy import Matrix, I, eye
        >>> m = Matrix((0, 1 + I, 2, 3))
        >>> m.D
        Matrix([[0, 1 - I, -2, -3]])
        >>> m = (eye(4) + I*eye(4))
        >>> m[0, 3] = 2
        >>> m.D
        Matrix([
        [1 - I,     0,      0,      0],
        [    0, 1 - I,      0,      0],
        [    0,     0, -1 + I,      0],
        [    2,     0,      0, -1 + I]])

        If the matrix does not have 4 rows an AttributeError will be raised
        because this property is only defined for matrices with 4 rows.

        >>> Matrix(eye(2)).D
        Traceback (most recent call last):
        ...
        AttributeError: Matrix has no attribute D.

        See Also
        ========

        conjugate: By-element conjugation
        H: Hermite conjugation
        """ 
        from sympy.physics.matrices import mgamma
        if self.rows!=4:
            raise AttributeError
        return self.H*mgamma(0)

    def diagonal_solve(self,rhs):
        rhs_3 = rhs;
        

        """Solves Ax = B efficiently, where A is a diagonal Matrix,
        with non-zero diagonal entries.

        Examples
        ========

        >>> from sympy.matrices import Matrix, eye
        >>> A = eye(2)*2
        >>> B = Matrix([[1, 2], [3, 4]])
        >>> A.diagonal_solve(B) == B/2
        True

        See Also
        ========

        lower_triangular_solve
        upper_triangular_solve
        gauss_jordan_solve
        cholesky_solve
        LDLsolve
        LUsolve
        QRsolve
        pinv_solve
        """ 
        if  not self.is_diagonal:
            raise TypeError("Matrix should be diagonal")
        if rhs_3.rows!=self.rows:
            raise TypeError("Size mis-match")
        return self._diagonal_solve(rhs_3)

    def dot(self,b):
        b_7 = b;
        mat_15=None;mat_16=None;mat_17=None;mat_18=None;b_8=None;b_9=None;b_10=None;prod_0=None;prod_1=None;

        """Return the dot product of Matrix self and b relaxing the condition
        of compatible dimensions: if either the number of rows or columns are
        the same as the length of b then the dot product is returned. If self
        is a row or column vector, a scalar is returned. Otherwise, a list
        of results is returned (and in that case the number of columns in self
        must match the length of b).

        Examples
        ========

        >>> from sympy import Matrix
        >>> M = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
        >>> v = [1, 1, 1]
        >>> M.row(0).dot(v)
        6
        >>> M.col(0).dot(v)
        12
        >>> M.dot(v)
        [6, 15, 24]

        See Also
        ========

        cross
        multiply
        multiply_elementwise
        """ 
        from .dense import Matrix
        if  not isinstance(b_7,MatrixBase):
            if is_sequence(b_7):
                if len(b_7)!=self.cols and len(b_7)!=self.rows:
                    raise ShapeError("Dimensions incorrect for dot product: %s, %s"%(self.shape,len(b_7)))
                return self.dot(Matrix(b_7))
            else:
                raise TypeError("`b` must be an ordered iterable or Matrix, not %s."%type(b_7))
        mat_15=self 
        if mat_15.cols==b_7.rows:
            if b_7.cols!=1:
                mat_16=mat_15.T 
                b_8=b_7.T 
            phiPreds = [b_7.cols!=1]
            phiNames = [mat_16,mat_15]
            mat_17= phiIf(phiPreds, phiNames)
            phiPreds = [b_7.cols!=1]
            phiNames = [b_8,b_7]
            b_9= phiIf(phiPreds, phiNames)
            prod_0=flatten((mat_17*b_9).tolist()) 
            if len(prod_0)==1:
                return prod_0[0]
            return prod_0
        phiPreds = [mat_15.cols==b_7.rows]
        phiNames = [mat_17,mat_15]
        mat_18= phiIf(phiPreds, phiNames)
        phiPreds = [mat_15.cols==b_7.rows]
        phiNames = [b_9,b_7]
        b_10= phiIf(phiPreds, phiNames)
        phiPreds = [mat_15.cols==b_7.rows]
        phiNames = [prod_0,None]
        prod_1= phiIf(phiPreds, phiNames)
        if mat_18.cols==b_10.cols:
            return mat_18.dot(b_10.T)
        elif mat_18.rows==b_10.rows:
            return mat_18.T.dot(b_10)
        else:
            raise ShapeError("Dimensions incorrect for dot product: %s, %s"%(self.shape,b_10.shape))

    def dual(self):
        
        work_0=None;acum_6=None;acum_4=None;acum_0=None;acum_2=None;acum_1=None;acum_3=None;acum_5=None;acum_7=None;acum_15=None;acum_8=None;acum_12=None;acum_10=None;acum_9=None;acum_11=None;acum_13=None;acum_14=None;acum_16=None;M_0=None;n_8=None;

        """Returns the dual of a matrix, which is:

        `(1/2)*levicivita(i, j, k, l)*M(k, l)` summed over indices `k` and `l`

        Since the levicivita method is anti_symmetric for any pairwise
        exchange of indices, the dual of a symmetric matrix is the zero
        matrix. Strictly speaking the dual defined here assumes that the
        'matrix' `M` is a contravariant anti_symmetric second rank tensor,
        so that the dual is a covariant second rank tensor.

        """ 
        from sympy import LeviCivita
        from sympy.matrices import zeros
        M_0,n_8=self[:,:],self.rows 
        work_0=zeros(n_8) 
        if self.is_symmetric():
            return work_0
        phi0 = Phi()
        for i_54 in range(1,n_8):
            phi0.set()
            acum_6 = phi0.phiEntry(None,acum_5)

            phi1 = Phi()
            for j_31 in range(1,n_8):
                phi1.set()
                acum_4 = phi1.phiEntry(acum_6,acum_3)

                acum_0=0 
                phi2 = Phi()
                for k_14 in range(1,n_8):
                    phi2.set()
                    acum_2 = phi2.phiEntry(acum_0,acum_1)

                    acum_1 = acum_2+LeviCivita(i_54,j_31,0,k_14)*M_0[0,k_14]
                acum_3 = phi2.phiExit(acum_0,acum_1)
                work_0[i_54,j_31]=acum_3 
                work_0[j_31,i_54]=-acum_3 
            acum_5 = phi1.phiExit(None,acum_3)
        acum_7 = phi0.phiExit(None,acum_5)
        phi0 = Phi()
        for l_4 in range(1,n_8):
            phi0.set()
            acum_15 = phi0.phiEntry(acum_7,acum_14)

            acum_8=0 
            phi1 = Phi()
            for a_10 in range(1,n_8):
                phi1.set()
                acum_12 = phi1.phiEntry(acum_8,acum_11)

                phi2 = Phi()
                for b_11 in range(1,n_8):
                    phi2.set()
                    acum_10 = phi2.phiEntry(acum_12,acum_9)

                    acum_9 = acum_10+LeviCivita(0,l_4,a_10,b_11)*M_0[a_10,b_11]
                acum_11 = phi2.phiExit(None,acum_9)
            acum_13 = phi1.phiExit(acum_8,acum_11)
            acum_14 = acum_13/2
            work_0[0,l_4]=-acum_14 
            work_0[l_4,0]=acum_14 
        acum_16 = phi0.phiExit(None,acum_14)
        return work_0

    def exp(self):
        
        nex_0=None;nex_2=None;nex_1=None;nex_3=None;nex_4=None;ret_25=None;res_0=None;res_1=None;res_2=None;b_12=None;nr_0=None;d_2=None;d_3=None;eJ_0=None;blocks_3=None;J_2=None;l_5=None;n_9=None;n_10=None;P_2=None;cells_0=None;

        """Return the exponentiation of a square matrix.""" 
        if  not self.is_square:
            raise NonSquareMatrixError("Exponentiation is valid only for square matrices")
        try:
            P_2,J_2=self.jordan_form() 
            cells_0=J_2.get_diag_blocks() 
        except MatrixError:
            raise NotImplementedError("Exponentiation is implemented only for matrices for which the Jordan normal form can be computed")
        def _jblock_exponential(b):
            b_12 = b;
            nex_0=None;nex_2=None;nex_1=None;nex_3=None;nex_4=None;res_0=None;res_1=None;res_2=None;nr_0=None;d_2=None;d_3=None;l_5=None;n_9=None;n_10=None;

            nr_0=b_12.rows 
            l_5=b_12[0,0] 
            if nr_0==1:
                res_0=exp(l_5) 
            else:
                from sympy import eye
                d_2=b_12[0,0]*eye(nr_0) 
                n_9=b_12-d_2 
                nex_0=eye(nr_0) 
                phi0 = Phi()
                for i_55 in range(1,nr_0):
                    phi0.set()
                    nex_2 = phi0.phiEntry(nex_0,nex_1)

                    nex_1=nex_2+n_9**i_55/factorial(i_55) 
                nex_3 = phi0.phiExit(nex_0,nex_1)
                res_1=exp(b_12[0,0])*nex_3 
            phiPreds = [nr_0==1]
            phiNames = [None,nex_3]
            nex_4= phiIf(phiPreds, phiNames)
            phiPreds = [nr_0==1]
            phiNames = [res_0,res_1]
            res_2= phiIf(phiPreds, phiNames)
            phiPreds = [nr_0==1]
            phiNames = [None,d_2]
            d_3= phiIf(phiPreds, phiNames)
            phiPreds = [nr_0==1]
            phiNames = [None,n_9]
            n_10= phiIf(phiPreds, phiNames)
            return (res_2)

        blocks_3=list(map(_jblock_exponential,cells_0)) 
        from sympy.matrices import diag
        eJ_0=diag(*blocks_3) 
        ret_25=P_2*eJ_0*P_2.inv() 
        return type(self)(ret_25)

    def gauss_jordan_solve(self,b,freevar=False):
        b_13 = b;freevar_0 = freevar;
        col_9=None;A_5=None;A_6=None;A_7=None;A_8=None;free_var_index_0=None;i_57=None;tau_0=None;pivots_9=None;pivots_10=None;free_sol_0=None;p_3=None;gen_0=None;sol_0=None;aug_0=None;v_8=None;V_0=None;name_0=None;rank_0=None;row_6=None;vt_0=None;permutation_0=None;permutation_1=None;

        """
        Solves Ax = b using Gauss Jordan elimination.

        There may be zero, one, or infinite solutions.  If one solution
        exists, it will be returned. If infinite solutions exist, it will
        be returned parametrically. If no solutions exist, It will throw
        ValueError.

        Parameters
        ==========

        b : Matrix
            The right hand side of the equation to be solved for.  Must have
            the same number of rows as matrix A.

        freevar : List
            If the system is underdetermined (e.g. A has more columns than
            rows), infinite solutions are possible, in terms of arbitrary
            values of free variables. Then the index of the free variables
            in the solutions (column Matrix) will be returned by freevar, if
            the flag `freevar` is set to `True`.

        Returns
        =======

        x : Matrix
            The matrix that will satisfy Ax = B.  Will have as many rows as
            matrix A has columns, and as many columns as matrix B.

        params : Matrix
            If the system is underdetermined (e.g. A has more columns than
            rows), infinite solutions are possible, in terms of arbitrary
            parameters. These arbitrary parameters are returned as params
            Matrix.

        Examples
        ========

        >>> from sympy import Matrix
        >>> A = Matrix([[1, 2, 1, 1], [1, 2, 2, -1], [2, 4, 0, 6]])
        >>> b = Matrix([7, 12, 4])
        >>> sol, params = A.gauss_jordan_solve(b)
        >>> sol
        Matrix([
        [-2*tau0 - 3*tau1 + 2],
        [                 tau0],
        [           2*tau1 + 5],
        [                 tau1]])
        >>> params
        Matrix([
        [tau0],
        [tau1]])

        >>> A = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 10]])
        >>> b = Matrix([3, 6, 9])
        >>> sol, params = A.gauss_jordan_solve(b)
        >>> sol
        Matrix([
        [-1],
        [ 2],
        [ 0]])
        >>> params
        Matrix(0, 1, [])

        See Also
        ========

        lower_triangular_solve
        upper_triangular_solve
        cholesky_solve
        diagonal_solve
        LDLsolve
        LUsolve
        QRsolve
        pinv

        References
        ==========

        .. [1] http://en.wikipedia.org/wiki/Gaussian_elimination

        """ 
        from sympy.matrices import Matrix,zeros
        aug_0=self.hstack(self.copy(),b_13.copy()) 
        row_6,col_9=aug_0[:,:-1].shape 
        A_5,pivots_9=aug_0.rref(simplify_8=True) 
        A_6,v_7=A_5[:,:-1],A_5[:,-1] 
        pivots_10=list(filter( lambda p_3 :p_3<col_9,pivots_9)) 
        rank_0=len(pivots_10) 
        permutation_0=Matrix(range(col_9)).T 
        A_7=A_6.vstack(A_6,permutation_0) 
        phi0 = Phi()
        for i_56,c_0 in enumerate(pivots_10):
            phi0.set()

            A_7.col_swap(i_56,c_0) 
        A_8,permutation_1=A_7[:-1,:],A_7[-1,:] 
        if  not v_7[rank_0:,0].is_zero:
            raise ValueError("Linear system has no solution")
        free_var_index_0=permutation_1[len(pivots_10):] 
        name_0=_uniquely_named_symbol('tau',aug_0,compare= lambda i_57 :str(i_57).rstrip('1234567890')).name 
        gen_0=numbered_symbols(name_0) 
        tau_0=Matrix([next(gen_0) for k_15 in range(col_9-rank_0)]).reshape(col_9-rank_0,1) 
        V_0=A_8[:rank_0,rank_0:] 
        vt_0=v_7[:rank_0,0] 
        free_sol_0=tau_0.vstack(vt_0-V_0*tau_0,tau_0) 
        sol_0=zeros(col_9,1) 
        phi0 = Phi()
        for k_16,v_8 in enumerate(free_sol_0):
            phi0.set()

            sol_0[permutation_1[k_16],0]=v_8 
        if freevar_0:
            return sol_0,tau_0,free_var_index_0
        else:
            return sol_0,tau_0

    def inv_mod(self,m):
        m_5 = m;
        phi_0=None;K_inv_0=None;det_inv_0=None;N_2=None;K_adj_0=None;det_K_0=None;

        r"""
        Returns the inverse of the matrix `K` (mod `m`), if it exists.

        Method to find the matrix inverse of `K` (mod `m`) implemented in this function:

        * Compute `\mathrm{adj}(K) = \mathrm{cof}(K)^t`, the adjoint matrix of `K`.

        * Compute `r = 1/\mathrm{det}(K) \pmod m`.

        * `K^{-1} = r\cdot \mathrm{adj}(K) \pmod m`.

        Examples
        ========

        >>> from sympy import Matrix
        >>> A = Matrix(2, 2, [1, 2, 3, 4])
        >>> A.inv_mod(5)
        Matrix([
        [3, 1],
        [4, 2]])
        >>> A.inv_mod(3)
        Matrix([
        [1, 1],
        [0, 1]])

        """ 
        from sympy.ntheory import totient
        if  not self.is_square:
            raise NonSquareMatrixError()
        N_2=self.cols 
        phi_0=totient(m_5) 
        det_K_0=self.det() 
        if gcd(det_K_0,m_5)!=1:
            raise ValueError('Matrix is not invertible (mod %d)'%m_5)
        det_inv_0=pow_0(int(det_K_0),int(phi_0-1),int(m_5)) 
        K_adj_0=self.adjugate() 
        K_inv_0=self.__class__(N_2,N_2,[det_inv_0*K_adj_0[i_58,j_32]%m_5 for i_58 in range(N_2) for j_32 in range(N_2)]) 
        return K_inv_0

    def inverse_ADJ(self,iszerofunc=_iszero):
        iszerofunc_10 = iszerofunc;
        zero_0=None;zero_1=None;zero_2=None;d_4=None;ok_0=None;ok_1=None;

        """Calculates the inverse using the adjugate matrix and a determinant.

        See Also
        ========

        inv
        inverse_LU
        inverse_GE
        """ 
        if  not self.is_square:
            raise NonSquareMatrixError("A Matrix must be square to invert.")
        d_4=self.det(method_11='berkowitz') 
        zero_0=d_4.equals(0) 
        if zero_0 is None:
            ok_0=self.rref(simplify_8=True)[0] 
            zero_1=any(iszerofunc_10(ok_0[j_33,j_33]) for j_33 in range(ok_0.rows)) 
        phiPreds = [zero_0 is None]
        phiNames = [zero_1,zero_0]
        zero_2= phiIf(phiPreds, phiNames)
        phiPreds = [zero_0 is None]
        phiNames = [ok_0,None]
        ok_1= phiIf(phiPreds, phiNames)
        if zero_2:
            raise ValueError("Matrix det == 0; not invertible.")
        return self.adjugate()/d_4

    def inverse_GE(self,iszerofunc=_iszero):
        iszerofunc_11 = iszerofunc;
        red_0=None;big_0=None;

        """Calculates the inverse using Gaussian elimination.

        See Also
        ========

        inv
        inverse_LU
        inverse_ADJ
        """ 
        from .dense import Matrix
        if  not self.is_square:
            raise NonSquareMatrixError("A Matrix must be square to invert.")
        big_0=Matrix.hstack(self.as_mutable(),Matrix.eye(self.rows)) 
        red_0=big_0.rref(iszerofunc=iszerofunc_11,simplify_8=True)[0] 
        if any(iszerofunc_11(red_0[j_34,j_34]) for j_34 in range(red_0.rows)):
            raise ValueError("Matrix det == 0; not invertible.")
        return self._new(red_0[:,big_0.rows:])

    def inverse_LU(self,iszerofunc=_iszero):
        iszerofunc_12 = iszerofunc;
        ok_2=None;

        """Calculates the inverse using LU decomposition.

        See Also
        ========

        inv
        inverse_GE
        inverse_ADJ
        """ 
        if  not self.is_square:
            raise NonSquareMatrixError()
        ok_2=self.rref(simplify_8=True)[0] 
        if any(iszerofunc_12(ok_2[j_35,j_35]) for j_35 in range(ok_2.rows)):
            raise ValueError("Matrix det == 0; not invertible.")
        return self.LUsolve(self.eye(self.rows),iszerofunc_12=_iszero)

    def inv(self,method=None,**kwargs):
        method_12 = method;kwargs_4 = kwargs;
        

        """
        Return the inverse of a matrix.

        CASE 1: If the matrix is a dense matrix.

        Return the matrix inverse using the method indicated (default
        is Gauss elimination).

        Parameters
        ==========

        method : ('GE', 'LU', or 'ADJ')

        Notes
        =====

        According to the ``method`` keyword, it calls the appropriate method:

          GE .... inverse_GE(); default
          LU .... inverse_LU()
          ADJ ... inverse_ADJ()

        See Also
        ========

        inverse_LU
        inverse_GE
        inverse_ADJ

        Raises
        ------
        ValueError
            If the determinant of the matrix is zero.

        CASE 2: If the matrix is a sparse matrix.

        Return the matrix inverse using Cholesky or LDL (default).

        kwargs
        ======

        method : ('CH', 'LDL')

        Notes
        =====

        According to the ``method`` keyword, it calls the appropriate method:

          LDL ... inverse_LDL(); default
          CH .... inverse_CH()

        Raises
        ------
        ValueError
            If the determinant of the matrix is zero.

        """ 
        if  not self.is_square:
            raise NonSquareMatrixError()
        if method_12 is  not None:
            kwargs_4['method']=method_12 
        return self._eval_inverse(**kwargs_4)

    def is_nilpotent(self):
        
        p_4=None;x_20=None;

        """Checks if a matrix is nilpotent.

        A matrix B is nilpotent if for some integer k, B**k is
        a zero matrix.

        Examples
        ========

        >>> from sympy import Matrix
        >>> a = Matrix([[0, 0, 0], [1, 0, 0], [1, 1, 0]])
        >>> a.is_nilpotent()
        True

        >>> a = Matrix([[1, 0, 1], [1, 0, 0], [1, 1, 0]])
        >>> a.is_nilpotent()
        False
        """ 
        if  not self:
            return True
        if  not self.is_square:
            raise NonSquareMatrixError("Nilpotency is valid only for square matrices")
        x_20=_uniquely_named_symbol('x',self) 
        p_4=self.charpoly(x_20) 
        if p_4.args[0]==x_20**self.rows:
            return True
        return False

    def key2bounds(self,keys):
        keys_0 = keys;
        jslice_0=None;rhi_0=None;rhi_1=None;rhi_2=None;rhi_3=None;rhi_4=None;rlo_0=None;rlo_1=None;rlo_2=None;rlo_3=None;rlo_4=None;chi_0=None;chi_1=None;chi_2=None;chi_3=None;chi_4=None;clo_0=None;clo_1=None;clo_2=None;clo_3=None;clo_4=None;islice_0=None;

        """Converts a key with potentially mixed types of keys (integer and slice)
        into a tuple of ranges and raises an error if any index is out of self's
        range.

        See Also
        ========

        key2ij
        """ 
        islice_0,jslice_0=[isinstance(k_17,slice) for k_17 in keys_0] 
        if islice_0:
            if  not self.rows:
                rlo_0=rhi_0=0 
            else:
                rlo_1,rhi_1=keys_0[0].indices(self.rows)[:2] 
            phiPreds = [ not self.rows]
            phiNames = [rhi_0,rhi_1]
            rhi_2= phiIf(phiPreds, phiNames)
            phiPreds = [ not self.rows]
            phiNames = [rlo_0,rlo_1]
            rlo_2= phiIf(phiPreds, phiNames)
        else:
            rlo_3=a2idx(keys_0[0],self.rows) 
            rhi_3=rlo_3+1 
        phiPreds = [islice_0]
        phiNames = [rhi_2,rhi_3]
        rhi_4= phiIf(phiPreds, phiNames)
        phiPreds = [islice_0]
        phiNames = [rlo_2,rlo_3]
        rlo_4= phiIf(phiPreds, phiNames)
        if jslice_0:
            if  not self.cols:
                clo_0=chi_0=0 
            else:
                clo_1,chi_1=keys_0[1].indices(self.cols)[:2] 
            phiPreds = [ not self.cols]
            phiNames = [chi_0,chi_1]
            chi_2= phiIf(phiPreds, phiNames)
            phiPreds = [ not self.cols]
            phiNames = [clo_0,clo_1]
            clo_2= phiIf(phiPreds, phiNames)
        else:
            clo_3=a2idx(keys_0[1],self.cols) 
            chi_3=clo_3+1 
        phiPreds = [jslice_0]
        phiNames = [chi_2,chi_3]
        chi_4= phiIf(phiPreds, phiNames)
        phiPreds = [jslice_0]
        phiNames = [clo_2,clo_3]
        clo_4= phiIf(phiPreds, phiNames)
        return rlo_4,rhi_4,clo_4,chi_4

    def key2ij(self,key):
        key_7 = key;
        

        """Converts key into canonical form, converting integers or indexable
        items into valid integers for self's range or returning slices
        unchanged.

        See Also
        ========

        key2bounds
        """ 
        if is_sequence(key_7):
            if  not len(key_7)==2:
                raise TypeError('key must be a sequence of length 2')
            return [a2idx(i_59,n_11) if  not isinstance(i_59,slice) else i_59 for i_59,n_11 in zip(key_7,self.shape)]
        elif isinstance(key_7,slice):
            return key_7.indices(len(self))[:2]
        else:
            return divmod(a2idx(key_7,len(self)),self.cols)

    def LDLdecomposition(self):
        
        

        """Returns the LDL Decomposition (L, D) of matrix A,
        such that L * D * L.T == A
        This method eliminates the use of square root.
        Further this ensures that all the diagonal entries of L are 1.
        A must be a square, symmetric, positive-definite
        and non-singular matrix.

        Examples
        ========

        >>> from sympy.matrices import Matrix, eye
        >>> A = Matrix(((25, 15, -5), (15, 18, 0), (-5, 0, 11)))
        >>> L, D = A.LDLdecomposition()
        >>> L
        Matrix([
        [   1,   0, 0],
        [ 3/5,   1, 0],
        [-1/5, 1/3, 1]])
        >>> D
        Matrix([
        [25, 0, 0],
        [ 0, 9, 0],
        [ 0, 0, 9]])
        >>> L * D * L.T * A.inv() == eye(A.rows)
        True

        See Also
        ========

        cholesky
        LUdecomposition
        QRdecomposition
        """ 
        if  not self.is_square:
            raise NonSquareMatrixError("Matrix must be square.")
        if  not self.is_symmetric():
            raise ValueError("Matrix must be symmetric.")
        return self._LDLdecomposition()

    def LDLsolve(self,rhs):
        rhs_4 = rhs;
        D_0=None;D_1=None;D_2=None;Y_1=None;Z_0=None;rhs_5=None;rhs_6=None;L_3=None;L_4=None;L_5=None;

        """Solves Ax = B using LDL decomposition,
        for a general square and non-singular matrix.

        For a non-square matrix with rows > cols,
        the least squares solution is returned.

        Examples
        ========

        >>> from sympy.matrices import Matrix, eye
        >>> A = eye(2)*2
        >>> B = Matrix([[1, 2], [3, 4]])
        >>> A.LDLsolve(B) == B/2
        True

        See Also
        ========

        LDLdecomposition
        lower_triangular_solve
        upper_triangular_solve
        gauss_jordan_solve
        cholesky_solve
        diagonal_solve
        LUsolve
        QRsolve
        pinv_solve
        """ 
        if self.is_symmetric():
            L_3,D_0=self.LDLdecomposition() 
        elif self.rows>=self.cols:
            L_4,D_1=(self.T*self).LDLdecomposition() 
            rhs_5=self.T*rhs_4 
        else:
            raise NotImplementedError('Under-determined System. ''Try M.gauss_jordan_solve(rhs)')
        phiPreds = [self.is_symmetric(),self.rows>=self.cols]
        phiNames = [D_0,D_1,None]
        D_2= phiIf(phiPreds, phiNames)
        phiPreds = [self.is_symmetric(),self.rows>=self.cols]
        phiNames = [L_3,L_4,None]
        L_5= phiIf(phiPreds, phiNames)
        phiPreds = [self.is_symmetric(),self.rows>=self.cols]
        phiNames = [rhs_4,rhs_5,rhs_4]
        rhs_6= phiIf(phiPreds, phiNames)
        Y_1=L_5._lower_triangular_solve(rhs_6) 
        Z_0=D_2._diagonal_solve(Y_1) 
        return (L_5.T)._upper_triangular_solve(Z_0)

    def lower_triangular_solve(self,rhs):
        rhs_7 = rhs;
        

        """Solves Ax = B, where A is a lower triangular matrix.

        See Also
        ========

        upper_triangular_solve
        gauss_jordan_solve
        cholesky_solve
        diagonal_solve
        LDLsolve
        LUsolve
        QRsolve
        pinv_solve
        """ 
        if  not self.is_square:
            raise NonSquareMatrixError("Matrix must be square.")
        if rhs_7.rows!=self.rows:
            raise ShapeError("Matrices size mismatch.")
        if  not self.is_lower:
            raise ValueError("Matrix must be lower triangular.")
        return self._lower_triangular_solve(rhs_7)

    def LUdecomposition(self,iszerofunc=_iszero,simpfunc=None,rankcheck=False):
        iszerofunc_13 = iszerofunc;simpfunc_9 = simpfunc;rankcheck_0 = rankcheck;
        p_5=None;U_0=None;i_60=None;i_61=None;j_36=None;j_37=None;combined_0=None;L_6=None;

        """Returns (L, U, perm) where L is a lower triangular matrix with unit
        diagonal, U is an upper triangular matrix, and perm is a list of row
        swap index pairs. If A is the original matrix, then
        A = (L*U).permuteBkwd(perm), and the row permutation matrix P such
        that P*A = L*U can be computed by P=eye(A.row).permuteFwd(perm).

        See documentation for LUCombined for details about the keyword argument
        rankcheck, iszerofunc, and simpfunc.

        Examples
        ========

        >>> from sympy import Matrix
        >>> a = Matrix([[4, 3], [6, 3]])
        >>> L, U, _ = a.LUdecomposition()
        >>> L
        Matrix([
        [  1, 0],
        [3/2, 1]])
        >>> U
        Matrix([
        [4,    3],
        [0, -3/2]])

        See Also
        ========

        cholesky
        LDLdecomposition
        QRdecomposition
        LUdecomposition_Simple
        LUdecompositionFF
        LUsolve
        """ 
        combined_0,p_5=self.LUdecomposition_Simple(iszerofunc=iszerofunc_13,simpfunc=simpfunc_9,rankcheck=rankcheck_0) 
        def entry_L(i,j):
            i_60 = i;j_34 = j;
            

            if i_60<j_34:
                return S.Zero
            elif i_60==j_34:
                return S.One
            elif j_34<combined_0.cols:
                return combined_0[i_60,j_34]
            return S.Zero

        def entry_U(i,j):
            i_61 = i;j_35 = j;
            

            return S.Zero if i_61>j_35 else combined_0[i_61,j_35]

        L_6=self._new(combined_0.rows,combined_0.rows,entry_L) 
        U_0=self._new(combined_0.rows,combined_0.cols,entry_U) 
        return L_6,U_0,p_5

    def LUdecomposition_Simple(self,iszerofunc=_iszero,simpfunc=None,rankcheck=False):
        iszerofunc_14 = iszerofunc;simpfunc_10 = simpfunc;rankcheck_1 = rankcheck;
        pivot_value_3=None;pivot_value_1=None;pivot_value_0=None;pivot_value_2=None;pivot_value_4=None;ind_simplified_pairs_3=None;ind_simplified_pairs_1=None;ind_simplified_pairs_0=None;ind_simplified_pairs_2=None;ind_simplified_pairs_4=None;sub_col_3=None;sub_col_1=None;sub_col_0=None;sub_col_2=None;sub_col_4=None;pivot_col_0=None;pivot_col_6=None;pivot_col_3=None;pivot_col_1=None;pivot_col_2=None;pivot_col_4=None;pivot_col_5=None;pivot_col_7=None;is_assumed_non_zero_3=None;is_assumed_non_zero_1=None;is_assumed_non_zero_0=None;is_assumed_non_zero_2=None;is_assumed_non_zero_4=None;lu_1=None;candidate_pivot_row_1=None;candidate_pivot_row_0=None;candidate_pivot_row_2=None;row_swaps_1=None;start_col_1=None;start_col_0=None;start_col_2=None;iszeropivot_4=None;iszeropivot_0=None;iszeropivot_2=None;iszeropivot_1=None;iszeropivot_3=None;iszeropivot_5=None;pivot_row_offset_3=None;pivot_row_offset_1=None;pivot_row_offset_0=None;pivot_row_offset_2=None;pivot_row_offset_4=None;

        """Compute an lu decomposition of m x n matrix A, where P*A = L*U

        * L is m x m lower triangular with unit diagonal
        * U is m x n upper triangular
        * P is an m x m permutation matrix

        Returns an m x n matrix lu, and an m element list perm where each
        element of perm is a pair of row exchange indices.

        The factors L and U are stored in lu as follows:
        The subdiagonal elements of L are stored in the subdiagonal elements
        of lu, that is lu[i, j] = L[i, j] whenever i > j.
        The elements on the diagonal of L are all 1, and are not explicitly
        stored.
        U is stored in the upper triangular portion of lu, that is
        lu[i ,j] = U[i, j] whenever i <= j.
        The output matrix can be visualized as:

            Matrix([
                [u, u, u, u],
                [l, u, u, u],
                [l, l, u, u],
                [l, l, l, u]])

        where l represents a subdiagonal entry of the L factor, and u
        represents an entry from the upper triangular entry of the U
        factor.

        perm is a list row swap index pairs such that if A is the original
        matrix, then A = (L*U).permuteBkwd(perm), and the row permutation
        matrix P such that ``P*A = L*U`` can be computed by
        ``P=eye(A.row).permuteFwd(perm)``.

        The keyword argument rankcheck determines if this function raises a
        ValueError when passed a matrix whose rank is strictly less than
        min(num rows, num cols). The default behavior is to decompose a rank
        deficient matrix. Pass rankcheck=True to raise a
        ValueError instead. (This mimics the previous behavior of this function).

        The keyword arguments iszerofunc and simpfunc are used by the pivot
        search algorithm.
        iszerofunc is a callable that returns a boolean indicating if its
        input is zero, or None if it cannot make the determination.
        simpfunc is a callable that simplifies its input.
        The default is simpfunc=None, which indicate that the pivot search
        algorithm should not attempt to simplify any candidate pivots.
        If simpfunc fails to simplify its input, then it must return its input
        instead of a copy.

        When a matrix contains symbolic entries, the pivot search algorithm
        differs from the case where every entry can be categorized as zero or
        nonzero.
        The algorithm searches column by column through the submatrix whose
        top left entry coincides with the pivot position.
        If it exists, the pivot is the first entry in the current search
        column that iszerofunc guarantees is nonzero.
        If no such candidate exists, then each candidate pivot is simplified
        if simpfunc is not None.
        The search is repeated, with the difference that a candidate may be
        the pivot if ``iszerofunc()`` cannot guarantee that it is nonzero.
        In the second search the pivot is the first candidate that
        iszerofunc can guarantee is nonzero.
        If no such candidate exists, then the pivot is the first candidate
        for which iszerofunc returns None.
        If no such candidate exists, then the search is repeated in the next
        column to the right.
        The pivot search algorithm differs from the one in `rref()`, which
        relies on ``_find_reasonable_pivot()``.
        Future versions of ``LUdecomposition_simple()`` may use
        ``_find_reasonable_pivot()``.

        See Also
        ========

        LUdecomposition
        LUdecompositionFF
        LUsolve
        """ 
        if rankcheck_1:
            pass
        if self.rows==0 or self.cols==0:
            return self.zeros(self.rows,self.cols),[]
        lu_1=self.as_mutable() 
        row_swaps_1=[] 
        pivot_col_0=0 
        phi0 = Phi()
        for pivot_row_0 in range(0,lu_1.rows-1):
            phi0.set()
            pivot_value_3 = phi0.phiEntry(None,pivot_value_2)
            ind_simplified_pairs_3 = phi0.phiEntry(None,ind_simplified_pairs_2)
            sub_col_3 = phi0.phiEntry(None,sub_col_2)
            pivot_col_6 = phi0.phiEntry(pivot_col_0,pivot_col_5)
            is_assumed_non_zero_3 = phi0.phiEntry(None,is_assumed_non_zero_2)
            candidate_pivot_row_1 = phi0.phiEntry(None,candidate_pivot_row_0)
            start_col_1 = phi0.phiEntry(None,start_col_0)
            iszeropivot_4 = phi0.phiEntry(None,iszeropivot_3)
            pivot_row_offset_3 = phi0.phiEntry(None,pivot_row_offset_2)

            iszeropivot_0=True 
            phi1 = Phi()
            while phi1.phiLoopTest(pivot_col_0,pivot_col_2)!=self.cols and phi1.phiLoopTest(iszeropivot_0,iszeropivot_1):
                phi1.set()
                pivot_value_1 = phi1.phiEntry(pivot_value_3,pivot_value_0)
                ind_simplified_pairs_1 = phi1.phiEntry(ind_simplified_pairs_3,ind_simplified_pairs_0)
                sub_col_1 = phi1.phiEntry(sub_col_3,sub_col_0)
                pivot_col_3 = phi1.phiEntry(pivot_col_6,pivot_col_2)
                is_assumed_non_zero_1 = phi1.phiEntry(is_assumed_non_zero_3,is_assumed_non_zero_0)
                iszeropivot_2 = phi1.phiEntry(iszeropivot_0,iszeropivot_1)
                pivot_row_offset_1 = phi1.phiEntry(pivot_row_offset_3,pivot_row_offset_0)

                sub_col_0=(lu_1[r_0,pivot_col_3] for r_0 in range(pivot_row_0,self.rows)) 
                pivot_row_offset_0,pivot_value_0,is_assumed_non_zero_0,ind_simplified_pairs_0=_find_reasonable_pivot_naive(sub_col_0,iszerofunc_14,simpfunc_10) 
                iszeropivot_1=pivot_value_0 is  None  
                if iszeropivot_1:
                    pivot_col_1 = pivot_col_3+1
                phiPreds = [iszeropivot_1]
                phiNames = [pivot_col_1,pivot_col_3]
                pivot_col_2= phiIf(phiPreds, phiNames)
            pivot_value_2 = phi1.phiExit(pivot_value_3,pivot_value_0)
            ind_simplified_pairs_2 = phi1.phiExit(ind_simplified_pairs_3,ind_simplified_pairs_0)
            sub_col_2 = phi1.phiExit(sub_col_3,sub_col_0)
            pivot_col_4 = phi1.phiExit(pivot_col_6,pivot_col_2)
            is_assumed_non_zero_2 = phi1.phiExit(is_assumed_non_zero_3,is_assumed_non_zero_0)
            iszeropivot_3 = phi1.phiExit(iszeropivot_0,iszeropivot_1)
            pivot_row_offset_2 = phi1.phiExit(pivot_row_offset_3,pivot_row_offset_0)
            if rankcheck_1 and pivot_col_4!=pivot_row_0:
                raise ValueError("Rank of matrix is strictly less than"" number of rows or columns."" Pass keyword argument"" rankcheck=False to compute"" the LU decomposition of this matrix.")
            candidate_pivot_row_0= None  if pivot_row_offset_2 is  None  else pivot_row_0+pivot_row_offset_2 
            if candidate_pivot_row_0 is None and iszeropivot_3:
                return lu_1,row_swaps_1
            phi1 = Phi()
            for offset_6,val_14 in ind_simplified_pairs_2:
                phi1.set()

                lu_1[pivot_row_0+offset_6,pivot_col_4]=val_14 
            if pivot_row_0!=candidate_pivot_row_0:
                row_swaps_1.append([pivot_row_0,candidate_pivot_row_0]) 
                lu_1[pivot_row_0,0:pivot_row_0],lu_1[candidate_pivot_row_0,0:pivot_row_0]=lu_1[candidate_pivot_row_0,0:pivot_row_0],lu_1[pivot_row_0,0:pivot_row_0] 
                lu_1[pivot_row_0,pivot_col_4:lu_1.cols],lu_1[candidate_pivot_row_0,pivot_col_4:lu_1.cols]=lu_1[candidate_pivot_row_0,pivot_col_4:lu_1.cols],lu_1[pivot_row_0,pivot_col_4:lu_1.cols] 
            start_col_0=pivot_col_4+1 
            phi1 = Phi()
            for row_7 in range(pivot_row_0+1,lu_1.rows):
                phi1.set()

                lu_1[row_7,pivot_row_0]=lu_1[row_7,pivot_col_4]/lu_1[pivot_row_0,pivot_col_4] 
                phi2 = Phi()
                for c_1 in range(start_col_0,lu_1.cols):
                    phi2.set()

                    lu_1[row_7,c_1]=lu_1[row_7,c_1]-lu_1[row_7,pivot_row_0]*lu_1[pivot_row_0,c_1] 
            if pivot_row_0!=pivot_col_4:
                phi1 = Phi()
                for row_8 in range(pivot_row_0+1,lu_1.rows):
                    phi1.set()

                    lu_1[row_8,pivot_col_4]=S.Zero 
            pivot_col_5 = pivot_col_4+1
            if pivot_col_5==lu_1.cols:
                return lu_1,row_swaps_1
        pivot_value_4 = phi0.phiExit(None,pivot_value_2)
        ind_simplified_pairs_4 = phi0.phiExit(None,ind_simplified_pairs_2)
        sub_col_4 = phi0.phiExit(None,sub_col_2)
        pivot_col_7 = phi0.phiExit(pivot_col_0,pivot_col_5)
        is_assumed_non_zero_4 = phi0.phiExit(None,is_assumed_non_zero_2)
        candidate_pivot_row_2 = phi0.phiExit(None,candidate_pivot_row_0)
        start_col_2 = phi0.phiExit(None,start_col_0)
        iszeropivot_5 = phi0.phiExit(None,iszeropivot_3)
        pivot_row_offset_4 = phi0.phiExit(None,pivot_row_offset_2)
        return lu_1,row_swaps_1

    def LUdecompositionFF(self):
        
        eye_0=None;P_3=None;DD_0=None;Ukk_1=None;Ukk_0=None;Ukk_2=None;U_1=None;Uik_3=None;Uik_1=None;Uik_0=None;Uik_2=None;Uik_4=None;oldpivot_0=None;oldpivot_2=None;oldpivot_1=None;oldpivot_3=None;L_7=None;zeros_4=None;m_8=None;n_12=None;

        """Compute a fraction-free LU decomposition.

        Returns 4 matrices P, L, D, U such that PA = L D**-1 U.
        If the elements of the matrix belong to some integral domain I, then all
        elements of L, D and U are guaranteed to belong to I.

        **Reference**
            - W. Zhou & D.J. Jeffrey, "Fraction-free matrix factors: new forms
              for LU and QR factors". Frontiers in Computer Science in China,
              Vol 2, no. 1, pp. 67-80, 2008.

        See Also
        ========

        LUdecomposition
        LUdecomposition_Simple
        LUsolve
        """ 
        from sympy.matrices import SparseMatrix
        zeros=SparseMatrix.zeros 
        eye=SparseMatrix.eye 
        n_12,m_6=self.rows,self.cols 
        U_1,L_7,P_3=self.as_mutable(),eye(n_12),eye(n_12) 
        DD_0=zeros(n_12,n_12) 
        oldpivot_0=1 
        phi0 = Phi()
        for k_18 in range(n_12-1):
            phi0.set()
            Ukk_1 = phi0.phiEntry(None,Ukk_0)
            Uik_3 = phi0.phiEntry(None,Uik_2)
            oldpivot_2 = phi0.phiEntry(oldpivot_0,oldpivot_1)

            if U_1[k_18,k_18]==0:
                phi1 = Phi()
                for kpivot_0 in range(k_18+1,n_12):
                    phi1.set()

                    if U_1[kpivot_0,k_18]:
                        break
                else:                    
                    raise ValueError("Matrix is not full rank")
                U_1[k_18,k_18:],U_1[kpivot_0,k_18:]=U_1[kpivot_0,k_18:],U_1[k_18,k_18:] 
                L_7[k_18,:k_18],L_7[kpivot_0,:k_18]=L_7[kpivot_0,:k_18],L_7[k_18,:k_18] 
                P_3[k_18,:],P_3[kpivot_0,:]=P_3[kpivot_0,:],P_3[k_18,:] 
            L_7[k_18,k_18]=Ukk_0=U_1[k_18,k_18] 
            DD_0[k_18,k_18]=oldpivot_2*Ukk_0 
            phi1 = Phi()
            for i_62 in range(k_18+1,n_12):
                phi1.set()
                Uik_1 = phi1.phiEntry(Uik_3,Uik_0)

                L_7[i_62,k_18]=Uik_0=U_1[i_62,k_18] 
                phi2 = Phi()
                for j_36 in range(k_18+1,m_6):
                    phi2.set()

                    U_1[i_62,j_36]=(Ukk_0*U_1[i_62,j_36]-U_1[k_18,j_36]*Uik_0)/oldpivot_2 
                U_1[i_62,k_18]=0 
            Uik_2 = phi1.phiExit(None,Uik_0)
            oldpivot_1=Ukk_0 
        Ukk_2 = phi0.phiExit(None,Ukk_0)
        Uik_4 = phi0.phiExit(None,Uik_2)
        oldpivot_3 = phi0.phiExit(oldpivot_0,oldpivot_1)
        DD_0[n_12-1,n_12-1]=oldpivot_3 
        return P_3,L_7,DD_0,U_1

    def LUsolve(self,rhs,iszerofunc=_iszero):
        rhs_8 = rhs;iszerofunc_15 = iszerofunc;
        A_9=None;b_14=None;perm_3=None;x_24=None;x_22=None;x_21=None;x_23=None;x_25=None;x_30=None;x_27=None;x_26=None;x_28=None;x_29=None;x_31=None;scale_3=None;scale_1=None;scale_0=None;scale_2=None;scale_4=None;scale_9=None;scale_6=None;scale_5=None;scale_7=None;scale_8=None;scale_10=None;y_3=None;y_1=None;y_0=None;y_2=None;y_4=None;y_8=None;y_6=None;y_5=None;y_7=None;y_9=None;n_13=None;

        """Solve the linear system Ax = rhs for x where A = self.

        This is for symbolic matrices, for real or complex ones use
        mpmath.lu_solve or mpmath.qr_solve.

        See Also
        ========

        lower_triangular_solve
        upper_triangular_solve
        gauss_jordan_solve
        cholesky_solve
        diagonal_solve
        LDLsolve
        QRsolve
        pinv_solve
        LUdecomposition
        """ 
        if rhs_8.rows!=self.rows:
            raise ShapeError("`self` and `rhs` must have the same number of rows.")
        A_9,perm_3=self.LUdecomposition_Simple(iszerofunc=_iszero) 
        n_13=self.rows 
        b_14=rhs_8.permute_rows(perm_3).as_mutable() 
        phi0 = Phi()
        for i_63 in range(n_13):
            phi0.set()
            x_24 = phi0.phiEntry(None,x_23)
            scale_3 = phi0.phiEntry(None,scale_2)
            y_3 = phi0.phiEntry(None,y_2)

            phi1 = Phi()
            for j_37 in range(i_63):
                phi1.set()
                x_22 = phi1.phiEntry(x_24,x_21)
                scale_1 = phi1.phiEntry(scale_3,scale_0)
                y_1 = phi1.phiEntry(y_3,y_0)

                scale_0=A_9[i_63,j_37] 
                b_14.zip_row_op(i_63,j_37, lambda x_22,y_1:x_22-y_1*scale_0) 
            x_23 = phi1.phiExit(None,x_21)
            scale_2 = phi1.phiExit(None,scale_0)
            y_2 = phi1.phiExit(None,y_0)
        x_25 = phi0.phiExit(None,x_23)
        scale_4 = phi0.phiExit(None,scale_2)
        y_4 = phi0.phiExit(None,y_2)
        phi0 = Phi()
        for i_64 in range(n_13-1,-1,-1):
            phi0.set()
            x_30 = phi0.phiEntry(x_23,x_29)
            scale_9 = phi0.phiEntry(scale_4,scale_8)
            y_8 = phi0.phiEntry(y_2,y_7)

            phi1 = Phi()
            for j_38 in range(i_64+1,n_13):
                phi1.set()
                x_27 = phi1.phiEntry(x_25,x_26)
                scale_6 = phi1.phiEntry(scale_9,scale_5)
                y_6 = phi1.phiEntry(y_4,y_5)

                scale_5=A_9[i_64,j_38] 
                b_14.zip_row_op(i_64,j_38, lambda x_30,y_8:x_30-y_8*scale_5) 
            x_28 = phi1.phiExit(None,x_26)
            scale_7 = phi1.phiExit(None,scale_5)
            y_7 = phi1.phiExit(None,y_5)
            scale_8=A_9[i_64,i_64] 
            b_14.row_op(i_64, lambda x_27,_:x_27/scale_8) 
        x_31 = phi0.phiExit(None,x_29)
        scale_10 = phi0.phiExit(None,scale_8)
        y_9 = phi0.phiExit(None,y_7)
        return rhs_8.__class__(b_14)

    def multiply(self,b):
        b_15 = b;
        

        """Returns self*b

        See Also
        ========

        dot
        cross
        multiply_elementwise
        """ 
        return self*b_15

    def normalized(self):
        
        i_65=None;norm_0=None;out_0=None;

        """Return the normalized version of ``self``.

        See Also
        ========

        norm
        """ 
        if self.rows!=1 and self.cols!=1:
            raise ShapeError("A Matrix must be a vector to normalize.")
        norm_0=self.norm() 
        out_0=self.applyfunc( lambda i_65 :i_65/norm_0) 
        return out_0

    def norm(self,ord=None):
        ord_0 = ord;
        vals_4=None;m_9=None;m_10=None;m_11=None;m_12=None;

        """Return the Norm of a Matrix or Vector.
        In the simplest case this is the geometric size of the vector
        Other norms can be specified by the ord parameter


        =====  ============================  ==========================
        ord    norm for matrices             norm for vectors
        =====  ============================  ==========================
        None   Frobenius norm                2-norm
        'fro'  Frobenius norm                - does not exist
        inf    maximum row sum               max(abs(x))
        -inf   --                            min(abs(x))
        1      maximum column sum            as below
        -1     --                            as below
        2      2-norm (largest sing. value)  as below
        -2     smallest singular value       as below
        other  - does not exist              sum(abs(x)**ord)**(1./ord)
        =====  ============================  ==========================

        Examples
        ========

        >>> from sympy import Matrix, Symbol, trigsimp, cos, sin, oo
        >>> x = Symbol('x', real=True)
        >>> v = Matrix([cos(x), sin(x)])
        >>> trigsimp( v.norm() )
        1
        >>> v.norm(10)
        (sin(x)**10 + cos(x)**10)**(1/10)
        >>> A = Matrix([[1, 1], [1, 1]])
        >>> A.norm(1) # maximum sum of absolute values of A is 2
        2
        >>> A.norm(2) # Spectral norm (max of |Ax|/|x| under 2-vector-norm)
        2
        >>> A.norm(-2) # Inverse spectral norm (smallest singular value)
        0
        >>> A.norm() # Frobenius Norm
        2
        >>> A.norm(oo) # Infinity Norm
        2
        >>> Matrix([1, -2]).norm(oo)
        2
        >>> Matrix([-1, 2]).norm(-oo)
        1

        See Also
        ========

        normalized
        """ 
        vals_4=list(self.values()) or [0] 
        if self.rows==1 or self.cols==1:
            if ord_0==2 or ord_0 is None:
                return sqrt(Add(*(abs(i_66)**2 for i_66 in vals_4)))
            elif ord_0==1:
                return Add(*(abs(i_67) for i_67 in vals_4))
            elif ord_0==S.Infinity:
                return Max(*[abs(i_68) for i_68 in vals_4])
            elif ord_0==S.NegativeInfinity:
                return Min(*[abs(i_69) for i_69 in vals_4])
            try:
                return Pow(Add(*(abs(i_70)**ord_0 for i_70 in vals_4)),S(1)/ord_0)
            except (NotImplementedError,TypeError):
                raise ValueError("Expected order to be Number, Symbol, oo")
        else:
            if ord_0==1:
                m_7=self.applyfunc(abs) 
                return Max(*[sum(m_7.col(i_71)) for i_71 in range(m_7.cols)])
            elif ord_0==2:
                return Max(*self.singular_values())
            elif ord_0==-2:
                return Min(*self.singular_values())
            elif ord_0==S.Infinity:
                m_8=self.applyfunc(abs) 
                return Max(*[sum(m_8.row(i_72)) for i_72 in range(m_8.rows)])
            elif (ord_0 is None or isinstance(ord_0,string_types) and ord_0.lower() in ['f','fro','frobenius','vector']):
                return self.vec().norm(ord_0=2)
            else:
                raise NotImplementedError("Matrix Norms under development")
            phiPreds = [ord_0==1,ord_0==2,ord_0==-2,ord_0==S.Infinity,(ord_0 is None or isinstance(ord_0,string_types) and ord_0.lower() in ['f','fro','frobenius','vector'])]
            phiNames = [m_9,None,None,m_10,None,None]
            m_11= phiIf(phiPreds, phiNames)
        phiPreds = [self.rows==1 or self.cols==1]
        phiNames = [None,m_11]
        m_12= phiIf(phiPreds, phiNames)

    def pinv_solve(self,B,arbitrary_matrix=None):
        B_1 = B;arbitrary_matrix_0 = arbitrary_matrix;
        arbitrary_matrix_1=None;arbitrary_matrix_2=None;A_10=None;A_pinv_0=None;w_0=None;w_1=None;rows_11=None;rows_12=None;cols_19=None;cols_20=None;

        """Solve Ax = B using the Moore-Penrose pseudoinverse.

        There may be zero, one, or infinite solutions.  If one solution
        exists, it will be returned.  If infinite solutions exist, one will
        be returned based on the value of arbitrary_matrix.  If no solutions
        exist, the least-squares solution is returned.

        Parameters
        ==========

        B : Matrix
            The right hand side of the equation to be solved for.  Must have
            the same number of rows as matrix A.
        arbitrary_matrix : Matrix
            If the system is underdetermined (e.g. A has more columns than
            rows), infinite solutions are possible, in terms of an arbitrary
            matrix.  This parameter may be set to a specific matrix to use
            for that purpose; if so, it must be the same shape as x, with as
            many rows as matrix A has columns, and as many columns as matrix
            B.  If left as None, an appropriate matrix containing dummy
            symbols in the form of ``wn_m`` will be used, with n and m being
            row and column position of each symbol.

        Returns
        =======

        x : Matrix
            The matrix that will satisfy Ax = B.  Will have as many rows as
            matrix A has columns, and as many columns as matrix B.

        Examples
        ========

        >>> from sympy import Matrix
        >>> A = Matrix([[1, 2, 3], [4, 5, 6]])
        >>> B = Matrix([7, 8])
        >>> A.pinv_solve(B)
        Matrix([
        [ _w0_0/6 - _w1_0/3 + _w2_0/6 - 55/18],
        [-_w0_0/3 + 2*_w1_0/3 - _w2_0/3 + 1/9],
        [ _w0_0/6 - _w1_0/3 + _w2_0/6 + 59/18]])
        >>> A.pinv_solve(B, arbitrary_matrix=Matrix([0, 0, 0]))
        Matrix([
        [-55/18],
        [   1/9],
        [ 59/18]])

        See Also
        ========

        lower_triangular_solve
        upper_triangular_solve
        gauss_jordan_solve
        cholesky_solve
        diagonal_solve
        LDLsolve
        LUsolve
        QRsolve
        pinv

        Notes
        =====

        This may return either exact solutions or least squares solutions.
        To determine which, check ``A * A.pinv() * B == B``.  It will be
        True if exact solutions exist, and False if only a least-squares
        solution exists.  Be aware that the left hand side of that equation
        may need to be simplified to correctly compare to the right hand
        side.

        References
        ==========

        .. [1] https://en.wikipedia.org/wiki/Moore-Penrose_pseudoinverse#Obtaining_all_solutions_of_a_linear_system

        """ 
        from sympy.matrices import eye
        A_10=self 
        A_pinv_0=self.pinv() 
        if arbitrary_matrix_0 is None:
            rows_11,cols_19=A_10.cols,B_1.cols 
            w_0=symbols('w:{0}_:{1}'.format(rows_11,cols_19),cls=Dummy) 
            arbitrary_matrix_1=self.__class__(cols_19,rows_11,w_0).T 
        phiPreds = [arbitrary_matrix_0 is None]
        phiNames = [arbitrary_matrix_1,arbitrary_matrix_0]
        arbitrary_matrix_2= phiIf(phiPreds, phiNames)
        phiPreds = [arbitrary_matrix_0 is None]
        phiNames = [w_0,None]
        w_1= phiIf(phiPreds, phiNames)
        phiPreds = [arbitrary_matrix_0 is None]
        phiNames = [rows_11,None]
        rows_12= phiIf(phiPreds, phiNames)
        phiPreds = [arbitrary_matrix_0 is None]
        phiNames = [cols_19,None]
        cols_20= phiIf(phiPreds, phiNames)
        return A_pinv_0*B_1+(eye(A_10.cols)-A_pinv_0*A_10)*arbitrary_matrix_2

    def pinv(self):
        
        A_11=None;AH_0=None;

        """Calculate the Moore-Penrose pseudoinverse of the matrix.

        The Moore-Penrose pseudoinverse exists and is unique for any matrix.
        If the matrix is invertible, the pseudoinverse is the same as the
        inverse.

        Examples
        ========

        >>> from sympy import Matrix
        >>> Matrix([[1, 2, 3], [4, 5, 6]]).pinv()
        Matrix([
        [-17/18,  4/9],
        [  -1/9,  1/9],
        [ 13/18, -2/9]])

        See Also
        ========

        inv
        pinv_solve

        References
        ==========

        .. [1] https://en.wikipedia.org/wiki/Moore-Penrose_pseudoinverse

        """ 
        A_11=self 
        AH_0=self.H 
        if A_11.is_zero:
            return AH_0
        try:
            if self.rows>=self.cols:
                return (AH_0*A_11).inv()*AH_0
            else:
                return AH_0*(A_11*AH_0).inv()
        except ValueError:
            raise NotImplementedError('Rank-deficient matrices are not yet ''supported.')

    def print_nonzero(self,symb="X"):
        symb_0 = symb;
        s_1=None;line_1=None;line_0=None;line_2=None;

        """Shows location of non-zero entries for fast shape lookup.

        Examples
        ========

        >>> from sympy.matrices import Matrix, eye
        >>> m = Matrix(2, 3, lambda i, j: i*3+j)
        >>> m
        Matrix([
        [0, 1, 2],
        [3, 4, 5]])
        >>> m.print_nonzero()
        [ XX]
        [XXX]
        >>> m = eye(4)
        >>> m.print_nonzero("x")
        [x   ]
        [ x  ]
        [  x ]
        [   x]

        """ 
        s_1=[] 
        phi0 = Phi()
        for i_73 in range(self.rows):
            phi0.set()
            line_1 = phi0.phiEntry(None,line_0)

            line_0=[] 
            phi1 = Phi()
            for j_39 in range(self.cols):
                phi1.set()

                if self[i_73,j_39]==0:
                    line_0.append(" ") 
                else:
                    line_0.append(str(symb_0)) 
            s_1.append("[%s]"%''.join(line_0)) 
        line_2 = phi0.phiExit(None,line_0)
        print('\n'.join(s_1)) 

    def project(self,v):
        v_9 = v;
        

        """Return the projection of ``self`` onto the line containing ``v``.

        Examples
        ========

        >>> from sympy import Matrix, S, sqrt
        >>> V = Matrix([sqrt(3)/2, S.Half])
        >>> x = Matrix([[1, 0]])
        >>> V.project(x)
        Matrix([[sqrt(3)/2, 0]])
        >>> V.project(-x)
        Matrix([[sqrt(3)/2, 0]])
        """ 
        return v_9*(self.dot(v_9)/v_9.dot(v_9))

    def QRdecomposition(self):
        
        mat_19=None;Q_0=None;R_4=None;tmp_4=None;tmp_0=None;tmp_2=None;tmp_1=None;tmp_3=None;tmp_5=None;rank_1=None;rank_4=None;rank_2=None;rank_3=None;rank_5=None;m_13=None;n_14=None;row_reduced_0=None;

        """Return Q, R where A = Q*R, Q is orthogonal and R is upper triangular.

        Examples
        ========

        This is the example from wikipedia:

        >>> from sympy import Matrix
        >>> A = Matrix([[12, -51, 4], [6, 167, -68], [-4, 24, -41]])
        >>> Q, R = A.QRdecomposition()
        >>> Q
        Matrix([
        [ 6/7, -69/175, -58/175],
        [ 3/7, 158/175,   6/175],
        [-2/7,    6/35,  -33/35]])
        >>> R
        Matrix([
        [14,  21, -14],
        [ 0, 175, -70],
        [ 0,   0,  35]])
        >>> A == Q*R
        True

        QR factorization of an identity matrix:

        >>> A = Matrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]])
        >>> Q, R = A.QRdecomposition()
        >>> Q
        Matrix([
        [1, 0, 0],
        [0, 1, 0],
        [0, 0, 1]])
        >>> R
        Matrix([
        [1, 0, 0],
        [0, 1, 0],
        [0, 0, 1]])

        See Also
        ========

        cholesky
        LDLdecomposition
        LUdecomposition
        QRsolve
        """ 
        cls=self.__class__ 
        mat_19=self.as_mutable() 
        if  not mat_19.rows>=mat_19.cols:
            raise MatrixError("The number of rows must be greater than columns")
        n_14=mat_19.rows 
        m_11=mat_19.cols 
        rank_1=n_14 
        row_reduced_0=mat_19.rref()[0] 
        phi0 = Phi()
        for i_74 in range(row_reduced_0.rows):
            phi0.set()
            rank_4 = phi0.phiEntry(rank_1,rank_3)

            if row_reduced_0.row(i_74).norm()==0:
                rank_2 = rank_4-1
            phiPreds = [row_reduced_0.row(i_74).norm()==0]
            phiNames = [rank_2,rank_4]
            rank_3= phiIf(phiPreds, phiNames)
        rank_5 = phi0.phiExit(rank_1,rank_3)
        if  not rank_5==mat_19.cols:
            raise MatrixError("The rank of the matrix must match the columns")
        Q_0,R_4=mat_19.zeros(n_14,m_11),mat_19.zeros(m_11) 
        phi0 = Phi()
        for j_40 in range(m_11):
            phi0.set()
            tmp_4 = phi0.phiEntry(None,tmp_3)

            tmp_0=mat_19[:,j_40] 
            phi1 = Phi()
            for i_75 in range(j_40):
                phi1.set()
                tmp_2 = phi1.phiEntry(tmp_0,tmp_1)

                tmp_1 = tmp_2-Q_0[:,i_75]*mat_19[:,j_40].dot(Q_0[:,i_75])
                tmp_1.expand() 
            tmp_3 = phi1.phiExit(tmp_0,tmp_1)
            R_4[j_40,j_40]=tmp_3.norm() 
            Q_0[:,j_40]=tmp_3/R_4[j_40,j_40] 
            if Q_0[:,j_40].norm()!=1:
                raise NotImplementedError("Could not normalize the vector %d."%j_40)
            phi1 = Phi()
            for i_76 in range(j_40):
                phi1.set()

                R_4[i_76,j_40]=Q_0[:,i_76].dot(mat_19[:,j_40]) 
        tmp_5 = phi0.phiExit(None,tmp_3)
        return cls(Q_0),cls(R_4)

    def QRsolve(self,b):
        b_16 = b;
        Q_1=None;R_5=None;tmp_10=None;tmp_6=None;tmp_8=None;tmp_7=None;tmp_9=None;tmp_11=None;x_32=None;y_10=None;n_15=None;

        """Solve the linear system 'Ax = b'.

        'self' is the matrix 'A', the method argument is the vector
        'b'.  The method returns the solution vector 'x'.  If 'b' is a
        matrix, the system is solved for each column of 'b' and the
        return value is a matrix of the same shape as 'b'.

        This method is slower (approximately by a factor of 2) but
        more stable for floating-point arithmetic than the LUsolve method.
        However, LUsolve usually uses an exact arithmetic, so you don't need
        to use QRsolve.

        This is mainly for educational purposes and symbolic matrices, for real
        (or complex) matrices use mpmath.qr_solve.

        See Also
        ========

        lower_triangular_solve
        upper_triangular_solve
        gauss_jordan_solve
        cholesky_solve
        diagonal_solve
        LDLsolve
        LUsolve
        pinv_solve
        QRdecomposition
        """ 
        Q_1,R_5=self.as_mutable().QRdecomposition() 
        y_7=Q_1.T*b_16 
        x_28=[] 
        n_15=R_5.rows 
        phi0 = Phi()
        for j_41 in range(n_15-1,-1,-1):
            phi0.set()
            tmp_10 = phi0.phiEntry(None,tmp_9)

            tmp_6=y_7[j_41,:] 
            phi1 = Phi()
            for k_19 in range(j_41+1,n_15):
                phi1.set()
                tmp_8 = phi1.phiEntry(tmp_6,tmp_7)

                tmp_7 = tmp_8-R_5[j_41,k_19]*x_28[n_15-1-k_19]
            tmp_9 = phi1.phiExit(tmp_6,tmp_7)
            x_28.append(tmp_9/R_5[j_41,j_41]) 
        tmp_11 = phi0.phiExit(None,tmp_9)
        return self._new([row_9._mat for row_9 in reversed(x_28)])

    def solve_least_squares(self,rhs,method='CH'):
        rhs_9 = rhs;method_13 = method;
        t_1=None;

        """Return the least-square fit to the data.

        By default the cholesky_solve routine is used (method='CH'); other
        methods of matrix inversion can be used. To find out which are
        available, see the docstring of the .inv() method.

        Examples
        ========

        >>> from sympy.matrices import Matrix, ones
        >>> A = Matrix([1, 2, 3])
        >>> B = Matrix([2, 3, 4])
        >>> S = Matrix(A.row_join(B))
        >>> S
        Matrix([
        [1, 2],
        [2, 3],
        [3, 4]])

        If each line of S represent coefficients of Ax + By
        and x and y are [2, 3] then S*xy is:

        >>> r = S*Matrix([2, 3]); r
        Matrix([
        [ 8],
        [13],
        [18]])

        But let's add 1 to the middle value and then solve for the
        least-squares value of xy:

        >>> xy = S.solve_least_squares(Matrix([8, 14, 18])); xy
        Matrix([
        [ 5/3],
        [10/3]])

        The error is given by S*xy - r:

        >>> S*xy - r
        Matrix([
        [1/3],
        [1/3],
        [1/3]])
        >>> _.norm().n(2)
        0.58

        If a different xy is used, the norm will be higher:

        >>> xy += ones(2, 1)/10
        >>> (S*xy - r).norm().n(2)
        1.5

        """ 
        if method_13=='CH':
            return self.cholesky_solve(rhs_9)
        t_1=self.T 
        return (t_1*self).inv(method_13=method_13)*t_1*rhs_9

    def solve(self,rhs,method='GE'):
        rhs_10 = rhs;method_14 = method;
        

        """Return solution to self*soln = rhs using given inversion method.

        For a list of possible inversion methods, see the .inv() docstring.
        """ 
        if  not self.is_square:
            if self.rows<self.cols:
                raise ValueError('Under-determined system. ''Try M.gauss_jordan_solve(rhs)')
            elif self.rows>self.cols:
                raise ValueError('For over-determined system, M, having ''more rows than columns, try M.solve_least_squares(rhs).')
        else:
            return self.inv(method_14=method_14)*rhs_10

    def table(self,printer,rowstart='[',rowend=']',rowsep='\n',colsep=', ',align='right'):
        printer_3 = printer;rowstart_0 = rowstart;rowend_0 = rowend;rowsep_0 = rowsep;colsep_0 = colsep;align_0 = align;
        res_3=None;s_5=None;s_3=None;s_2=None;s_4=None;s_6=None;align_1=None;maxlen_0=None;

        r"""
        String form of Matrix as a table.

        ``printer`` is the printer to use for on the elements (generally
        something like StrPrinter())

        ``rowstart`` is the string used to start each row (by default '[').

        ``rowend`` is the string used to end each row (by default ']').

        ``rowsep`` is the string used to separate rows (by default a newline).

        ``colsep`` is the string used to separate columns (by default ', ').

        ``align`` defines how the elements are aligned. Must be one of 'left',
        'right', or 'center'.  You can also use '<', '>', and '^' to mean the
        same thing, respectively.

        This is used by the string printer for Matrix.

        Examples
        ========

        >>> from sympy import Matrix
        >>> from sympy.printing.str import StrPrinter
        >>> M = Matrix([[1, 2], [-33, 4]])
        >>> printer = StrPrinter()
        >>> M.table(printer)
        '[  1, 2]\n[-33, 4]'
        >>> print(M.table(printer))
        [  1, 2]
        [-33, 4]
        >>> print(M.table(printer, rowsep=',\n'))
        [  1, 2],
        [-33, 4]
        >>> print('[%s]' % M.table(printer, rowsep=',\n'))
        [[  1, 2],
        [-33, 4]]
        >>> print(M.table(printer, colsep=' '))
        [  1 2]
        [-33 4]
        >>> print(M.table(printer, align='center'))
        [ 1 , 2]
        [-33, 4]
        >>> print(M.table(printer, rowstart='{', rowend='}'))
        {  1, 2}
        {-33, 4}
        """ 
        if self.rows==0 or self.cols==0:
            return '[]'
        res_3=[] 
        maxlen_0=[0]*self.cols 
        phi0 = Phi()
        for i_77 in range(self.rows):
            phi0.set()
            s_5 = phi0.phiEntry(None,s_4)

            res_3.append([]) 
            phi1 = Phi()
            for j_42 in range(self.cols):
                phi1.set()
                s_3 = phi1.phiEntry(s_5,s_2)

                s_2=printer_3._print(self[i_77,j_42]) 
                res_3[-1].append(s_2) 
                maxlen_0[j_42]=max(len(s_2),maxlen_0[j_42]) 
            s_4 = phi1.phiExit(None,s_2)
        s_6 = phi0.phiExit(None,s_4)
        align_1={'left':'ljust','right':'rjust','center':'center','<':'ljust','>':'rjust','^':'center',}[align_0] 
        phi0 = Phi()
        for i_78,row_10 in enumerate(res_3):
            phi0.set()

            phi1 = Phi()
            for j_43,elem_0 in enumerate(row_10):
                phi1.set()

                row_10[j_43]=getattr(elem_0,align_1)(maxlen_0[j_43]) 
            res_3[i_78]=rowstart_0+colsep_0.join(row_10)+rowend_0 
        return rowsep_0.join(res_3)

    def upper_triangular_solve(self,rhs):
        rhs_11 = rhs;
        

        """Solves Ax = B, where A is an upper triangular matrix.

        See Also
        ========

        lower_triangular_solve
        gauss_jordan_solve
        cholesky_solve
        diagonal_solve
        LDLsolve
        LUsolve
        QRsolve
        pinv_solve
        """ 
        if  not self.is_square:
            raise NonSquareMatrixError("Matrix must be square.")
        if rhs_11.rows!=self.rows:
            raise TypeError("Matrix size mismatch.")
        if  not self.is_upper:
            raise TypeError("Matrix is not upper triangular.")
        return self._upper_triangular_solve(rhs_11)

    def vech(self,diagonal=True,check_symmetry=True):
        diagonal_0 = diagonal;check_symmetry_0 = check_symmetry;
        c_2=None;v_11=None;v_12=None;v_13=None;count_0=None;count_4=None;count_2=None;count_1=None;count_3=None;count_5=None;count_9=None;count_7=None;count_6=None;count_8=None;count_10=None;count_11=None;

        """Return the unique elements of a symmetric Matrix as a one column matrix
        by stacking the elements in the lower triangle.

        Arguments:
        diagonal -- include the diagonal cells of self or not
        check_symmetry -- checks symmetry of self but not completely reliably

        Examples
        ========

        >>> from sympy import Matrix
        >>> m=Matrix([[1, 2], [2, 3]])
        >>> m
        Matrix([
        [1, 2],
        [2, 3]])
        >>> m.vech()
        Matrix([
        [1],
        [2],
        [3]])
        >>> m.vech(diagonal=False)
        Matrix([[2]])

        See Also
        ========

        vec
        """ 
        from sympy.matrices import zeros
        c_2=self.cols 
        if c_2!=self.rows:
            raise ShapeError("Matrix must be square")
        if check_symmetry_0:
            self.simplify() 
            if self!=self.transpose():
                raise ValueError("Matrix appears to be asymmetric; consider check_symmetry=False")
        count_0=0 
        if diagonal_0:
            v_10=zeros(c_2*(c_2+1)//2,1) 
            phi0 = Phi()
            for j_44 in range(c_2):
                phi0.set()
                count_4 = phi0.phiEntry(count_0,count_3)

                phi1 = Phi()
                for i_79 in range(j_44,c_2):
                    phi1.set()
                    count_2 = phi1.phiEntry(count_4,count_1)

                    v_10[count_2]=self[i_79,j_44] 
                    count_1 = count_2+1
                count_3 = phi1.phiExit(None,count_1)
            count_5 = phi0.phiExit(count_0,count_3)
        else:
            v_11=zeros(c_2*(c_2-1)//2,1) 
            phi0 = Phi()
            for j_45 in range(c_2):
                phi0.set()
                count_9 = phi0.phiEntry(count_0,count_8)

                phi1 = Phi()
                for i_80 in range(j_45+1,c_2):
                    phi1.set()
                    count_7 = phi1.phiEntry(count_9,count_6)

                    v_11[count_7]=self[i_80,j_45] 
                    count_6 = count_7+1
                count_8 = phi1.phiExit(None,count_6)
            count_10 = phi0.phiExit(count_0,count_8)
        phiPreds = [diagonal_0]
        phiNames = [v_11,v_12]
        v_13= phiIf(phiPreds, phiNames)
        phiPreds = [diagonal_0]
        phiNames = [count_5,count_10]
        count_11= phiIf(phiPreds, phiNames)
        return v_12

def classof(A,B):
    A_12 = A;B_2 = B;
    

    """
    Get the type of the result when combining matrices of different types.

    Currently the strategy is that immutability is contagious.

    Examples
    ========

    >>> from sympy import Matrix, ImmutableMatrix
    >>> from sympy.matrices.matrices import classof
    >>> M = Matrix([[1, 2], [3, 4]]) # a Mutable Matrix
    >>> IM = ImmutableMatrix([[1, 2], [3, 4]])
    >>> classof(M, IM)
    <class 'sympy.matrices.immutable.ImmutableDenseMatrix'>
    """ 
    try:
        if A_12._class_priority>B_2._class_priority:
            return A_12.__class__
        else:
            return B_2.__class__
    except AttributeError:
        pass
    try:
        import numpy
        if isinstance(A_12,numpy.ndarray):
            return B_2.__class__
        if isinstance(B_2,numpy.ndarray):
            return A_12.__class__
    except (AttributeError,ImportError):
        pass
    raise TypeError("Incompatible classes %s, %s"%(A_12.__class__,B_2.__class__))

def a2idx(j,n=None):
    j_46 = j;n_16 = n;
    j_49=None;j_50=None;j_51=None;j_52=None;j_53=None;

    """Return integer after making positive and validating against n.""" 
    if type(j_46) is  not int:
        try:
            j_47=j_46.__index__() 
        except AttributeError:
            raise IndexError("Invalid index a[%r]"%(j_46,))
    phiPreds = [type(j_46) is  not int]
    phiNames = [j_49,None]
    j_50= phiIf(phiPreds, phiNames)
    if n_16 is  not None:
        if j_48<0:
            j_49 = j_48+n_16
        phiPreds = [j_48<0]
        phiNames = [j_51,j_48]
        j_52= phiIf(phiPreds, phiNames)
        if  not (j_50>=0 and j_50<n_16):
            raise IndexError("Index out of range: a[%s]"%j_50)
    phiPreds = [n_16 is  not None]
    phiNames = [j_52,j_48]
    j_53= phiIf(phiPreds, phiNames)
    return int(j_51)

def _find_reasonable_pivot(col,iszerofunc=_iszero,simpfunc=_simplify):
    col_10 = col;iszerofunc_16 = iszerofunc;simpfunc_11 = simpfunc;
    simped_1=None;simped_0=None;simped_2=None;col_11=None;col_abs_0=None;col_abs_1=None;is_zero_1=None;is_zero_0=None;is_zero_2=None;is_zero_4=None;is_zero_3=None;is_zero_5=None;possible_zeros_0=None;newly_determined_3=None;newly_determined_4=None;newly_determined_5=None;newly_determined_6=None;newly_determined_7=None;index_0=None;index_1=None;i_85=None;max_value_0=None;max_value_1=None;

    """ Find the lowest index of an item in `col` that is
    suitable for a pivot.  If `col` consists only of
    Floats, the pivot with the largest norm is returned.
    Otherwise, the first element where `iszerofunc` returns
    False is used.  If `iszerofunc` doesn't return false,
    items are simplified and retested until a suitable
    pivot is found.

    Returns a 4-tuple
        (pivot_offset, pivot_val, assumed_nonzero, newly_determined)
    where pivot_offset is the index of the pivot, pivot_val is
    the (possibly simplified) value of the pivot, assumed_nonzero
    is True if an assumption that the pivot was non-zero
    was made without being proved, and newly_determined are
    elements that were simplified during the process of pivot
    finding.""" 
    newly_determined_3=[] 
    col_11=list(col_10) 
    if all(isinstance(x_33,(Float,Integer)) for x_33 in col_11) and any(isinstance(x_34,Float) for x_34 in col_11):
        col_abs_0=[abs(x_35) for x_35 in col_11] 
        max_value_0=max(col_abs_0) 
        if iszerofunc_16(max_value_0):
            if max_value_0!=0:
                newly_determined_4=[(i_81,0) for i_81,x_36 in enumerate(col_11) if x_36!=0] 
            phiPreds = [max_value_0!=0]
            phiNames = [newly_determined_4,newly_determined_3]
            newly_determined_5= phiIf(phiPreds, phiNames)
            return (None,None,False,newly_determined_5)
        phiPreds = [iszerofunc_16(max_value_0)]
        phiNames = [newly_determined_5,newly_determined_3]
        newly_determined_6= phiIf(phiPreds, phiNames)
        index_0=col_abs_0.index(max_value_0) 
        return (index_0,col_11[index_0],False,newly_determined_6)
    phiPreds = [all(isinstance(x_33,(Float,Integer)) for x_33 in col_11) and any(isinstance(x_34,Float) for x_34 in col_11)]
    phiNames = [col_abs_0,None]
    col_abs_1= phiIf(phiPreds, phiNames)
    phiPreds = [all(isinstance(x_33,(Float,Integer)) for x_33 in col_11) and any(isinstance(x_34,Float) for x_34 in col_11)]
    phiNames = [newly_determined_6,newly_determined_3]
    newly_determined_7= phiIf(phiPreds, phiNames)
    phiPreds = [all(isinstance(x_33,(Float,Integer)) for x_33 in col_11) and any(isinstance(x_34,Float) for x_34 in col_11)]
    phiNames = [index_0,None]
    index_1= phiIf(phiPreds, phiNames)
    phiPreds = [all(isinstance(x_33,(Float,Integer)) for x_33 in col_11) and any(isinstance(x_34,Float) for x_34 in col_11)]
    phiNames = [max_value_0,None]
    max_value_1= phiIf(phiPreds, phiNames)
    possible_zeros_0=[] 
    phi0 = Phi()
    for i_82,x_29 in enumerate(col_11):
        phi0.set()
        is_zero_1 = phi0.phiEntry(None,is_zero_0)

        is_zero_0=iszerofunc_16(x_29) 
        if is_zero_0==False:
            return (i_82,x_29,False,newly_determined_7)
        possible_zeros_0.append(is_zero_0) 
    is_zero_2 = phi0.phiExit(None,is_zero_0)
    if all(possible_zeros_0):
        return (None,None,False,newly_determined_7)
    phi0 = Phi()
    for i_83,x_31 in enumerate(col_11):
        phi0.set()
        simped_1 = phi0.phiEntry(None,simped_0)
        is_zero_4 = phi0.phiEntry(is_zero_2,is_zero_3)

        if possible_zeros_0[i_83] is  not None:
            continue
        simped_0=simpfunc_11(x_31) 
        is_zero_3=iszerofunc_16(simped_0) 
        if is_zero_3==True or is_zero_3==False:
            newly_determined_7.append((i_83,simped_0)) 
        if is_zero_3==False:
            return (i_83,simped_0,False,newly_determined_7)
        possible_zeros_0[i_83]=is_zero_3 
    simped_2 = phi0.phiExit(None,simped_0)
    is_zero_5 = phi0.phiExit(None,is_zero_3)
    if all(possible_zeros_0):
        return (None,None,False,newly_determined_7)
    phi0 = Phi()
    for i_84,x_32 in enumerate(col_11):
        phi0.set()

        if possible_zeros_0[i_84] is  not None:
            continue
        if x_32.equals(S.Zero):
            possible_zeros_0[i_84]=True 
            newly_determined_7.append((i_84,S.Zero)) 
    if all(possible_zeros_0):
        return (None,None,False,newly_determined_7)
    i_85=possible_zeros_0.index( None ) 
    return (i_85,col_11[i_85],True,newly_determined_7)

def _find_reasonable_pivot_naive(col,iszerofunc=_iszero,simpfunc=None):
    col_12 = col;iszerofunc_17 = iszerofunc;simpfunc_12 = simpfunc;
    tmp_col_val_1=None;tmp_col_val_0=None;tmp_col_val_2=None;col_val_is_zero_1=None;col_val_is_zero_0=None;col_val_is_zero_2=None;indeterminates_0=None;newly_determined_8=None;

    """
    Helper that computes the pivot value and location from a
    sequence of contiguous matrix column elements. As a side effect
    of the pivot search, this function may simplify some of the elements
    of the input column. A list of these simplified entries and their
    indices are also returned.
    This function mimics the behavior of _find_reasonable_pivot(),
    but does less work trying to determine if an indeterminate candidate
    pivot simplifies to zero. This more naive approach can be much faster,
    with the trade-off that it may erroneously return a pivot that is zero.

    `col` is a sequence of contiguous column entries to be searched for
    a suitable pivot.
    `iszerofunc` is a callable that returns a Boolean that indicates
    if its input is zero, or None if no such determination can be made.
    `simpfunc` is a callable that simplifies its input. It must return
    its input if it does not simplify its input. Passing in
    `simpfunc=None` indicates that the pivot search should not attempt
    to simplify any candidate pivots.

    Returns a 4-tuple:
    (pivot_offset, pivot_val, assumed_nonzero, newly_determined)
    `pivot_offset` is the sequence index of the pivot.
    `pivot_val` is the value of the pivot.
    pivot_val and col[pivot_index] are equivalent, but will be different
    when col[pivot_index] was simplified during the pivot search.
    `assumed_nonzero` is a boolean indicating if the pivot cannot be
    guaranteed to be zero. If assumed_nonzero is true, then the pivot
    may or may not be non-zero. If assumed_nonzero is false, then
    the pivot is non-zero.
    `newly_determined` is a list of index-value pairs of pivot candidates
    that were simplified during the pivot search.
    """ 
    indeterminates_0=[] 
    phi0 = Phi()
    for i_86,col_val_0 in enumerate(col_12):
        phi0.set()
        col_val_is_zero_1 = phi0.phiEntry(None,col_val_is_zero_0)

        col_val_is_zero_0=iszerofunc_17(col_val_0) 
        if col_val_is_zero_0==False:
            return i_86,col_val_0,False,[]
        elif col_val_is_zero_0 is None:
            indeterminates_0.append((i_86,col_val_0)) 
    col_val_is_zero_2 = phi0.phiExit(None,col_val_is_zero_0)
    if len(indeterminates_0)==0:
        return None,None,False,[]
    if simpfunc_12 is None:
        return indeterminates_0[0][0],indeterminates_0[0][1],True,[]
    newly_determined_8=[] 
    phi0 = Phi()
    for i_87,col_val_1 in indeterminates_0:
        phi0.set()
        tmp_col_val_1 = phi0.phiEntry(None,tmp_col_val_0)

        tmp_col_val_0=simpfunc_12(col_val_1) 
        if id(col_val_1)!=id(tmp_col_val_0):
            newly_determined_8.append((i_87,tmp_col_val_0)) 
            if iszerofunc_17(tmp_col_val_0)==False:
                return i_87,tmp_col_val_0,False,newly_determined_8
    tmp_col_val_2 = phi0.phiExit(None,tmp_col_val_0)
    return indeterminates_0[0][0],indeterminates_0[0][1],True,newly_determined_8



#generate python causal map
causal_map = {'complex_0':[],'P_0':[],'P_2':[],'P_1':[],'sign_3':['sign_1','sign_2'],'sign_2':['sign_3'],'P_3':['n_12','n_12'],'jordan_mat_1':['jordan_mat_0','eigs_1','mat_13'],'A_pinv_0':[],'jordan_mat_0':['mat_13','blocks_0'],'sign_4':['sign_1','sign_2'],'align_1':['align_0'],'jordan_mat_2':['mat_13','blocks_2'],'end_0':['d_1','d_1','d_1','d_1'],'count_7':['count_9','count_6'],'count_6':['count_7'],'count_5':['count_0','count_3'],'count_4':['count_0','count_3'],'assumed_nonzero_1':['assumed_nonzero_0'],'count_3':['count_1'],'assumed_nonzero_2':['assumed_nonzero_0'],'count_2':['count_4','count_1'],'count_1':['count_2'],'count_0':[],'sign_1':[],'sign_0':['pivot_pos_0'],'count_9':['count_0','count_8'],'count_8':['count_6'],'p_4':['x_20'],'p_5':['iszerofunc_13','simpfunc_9','rankcheck_0'],'oldpivot_2':['oldpivot_0','oldpivot_1'],'aug_0':['b_13'],'oldpivot_3':['oldpivot_0','oldpivot_1'],'oldpivot_0':[],'assumed_nonzero_0':['piv_col_3','piv_row_2','iszerofunc_5','simpfunc_3'],'oldpivot_1':['Ukk_0'],'DD_0':['n_12','n_12'],'val_2':['val_4','val_1'],'val_3':['val_1'],'val_4':['val_3'],'val_5':['val_3'],'val_1':['mat_1','row_2','cols_6','piv_col_2'],'key_3':['i_53','i_53','value_2','j_30','j_30','value_2'],'acum_4':['acum_6','acum_3'],'basis_0':[],'key_2':['i_53','j_30'],'acum_3':['acum_0','acum_1'],'key_1':['key_0'],'acum_2':['acum_0','acum_1'],'acum_1':['acum_2','i_54','j_31','k_14','M_0','k_14'],'acum_0':[],'key_6':['key_1','key_5','j_30','i_53'],'key_5':['key_4','key_1','is_mat_2'],'nr_0':['b_12'],'key_4':['key_2','key_3','is_slice_0'],'polys_0':['A_4'],'arr_2':['arr_1','args_8'],'acum_9':['acum_10','l_4','a_10','b_11','M_0','a_10','b_11'],'acum_8':[],'acum_7':['acum_5'],'arr_0':['args_8'],'acum_6':['acum_5'],'arr_1':['arr_0','args_8'],'acum_5':['acum_3'],'simpfunc_5':['simplify_2','simplify_2'],'simpfunc_4':['simplify_1','simplify_1'],'simplify_7':['flags_1'],'simpfunc_8':['simpfunc_7','simplify_7'],'simpfunc_7':['simplify_7'],'simpfunc_6':['simplify_3','simplify_3'],'is_assumed_non_zero_0':['sub_col_0','iszerofunc_14','simpfunc_10'],'is_assumed_non_zero_2':['is_assumed_non_zero_3','is_assumed_non_zero_0'],'is_assumed_non_zero_1':['is_assumed_non_zero_3','is_assumed_non_zero_0'],'is_assumed_non_zero_4':['is_assumed_non_zero_2'],'is_assumed_non_zero_3':['is_assumed_non_zero_2'],'N_0':[],'N_2':[],'N_1':['jc_0'],'block_structure_0':[],'item_doit_1':['item_doit_0','attr_0'],'item_doit_0':['attr_0','args_6'],'acum_16':['acum_14'],'acum_15':['acum_7','acum_14'],'acum_14':['acum_13'],'acum_13':['acum_8','acum_11'],'acum_12':['acum_8','acum_11'],'acum_11':['acum_9'],'acum_10':['acum_12','acum_9'],'is_zero_2':['is_zero_0'],'is_zero_3':['iszerofunc_16','simped_0'],'is_zero_4':['is_zero_2','is_zero_3'],'is_zero_5':['is_zero_3'],'col_6':['col_5','col_4','op_0'],'col_5':['col1_3','col_4','col_4'],'col_4':['col_3','col_2','op_0'],'is_zero_0':['iszerofunc_16','x_29'],'col_3':['col_2','col_2','col1_1'],'is_zero_1':['is_zero_0'],'free_var_index_0':['permutation_1','pivots_10'],'col_9':['aug_0'],'n_0':[],'col_8':['op_1','col_7','k_6','col1_4','col2_7'],'n_2':['X_2'],'maxlen_0':[],'n_4':['n_2','n_3','X_2'],'n_3':['X_2'],'n_8':[],'n_9':['b_12','d_2'],'indeterminates_0':[],'row_reduced_0':['mat_19'],'M_0':[],'candidate_pivot_row_2':['candidate_pivot_row_0'],'candidate_pivot_row_1':['candidate_pivot_row_0'],'candidate_pivot_row_0':['pivot_row_offset_2','pivot_row_0','pivot_row_offset_2'],'max_prec_0':[],'max_prec_1':[],'max_prec_2':['max_prec_0','has_floats_1'],'primitive_0':['flags_1'],'rank_1':['n_14'],'rank_2':['rank_4'],'rank_0':['pivots_10'],'bn_1':['bn_0'],'prod_1':['prod_0','b_7','mat_15'],'bn_2':['bn_1','bn_0','bn_0'],'prod_0':['mat_17','b_9'],'eig_basis_0':[],'bn_0':['n_7','i_46'],'eig_basis_2':['eig_basis_0'],'eig_basis_1':['eig_basis_0'],'ncol_1':['ncol_0','args_8'],'ncol_2':['ncol_1','args_8'],'minors_0':[],'m_1':[],'m_0':['mat_10','mat_10','eigenval_0'],'ncol_0':[],'basis_mat_0':['mat_13','jordan_basis_0'],'vec_9':['vec_9','vec_8'],'m_3':[],'line_1':['line_0'],'basis_mat_1':['basis_mat_0','eigs_1','mat_13'],'line_2':['line_0'],'vec_7':['vec_7','vec_6'],'basis_mat_2':['mat_13','jordan_basis_2'],'vec_8':['vec_6'],'line_0':[],'m_7':[],'vec_6':['null_small_0','eig_basis_0','null_big_0'],'m_6':[],'m_8':[],'vec_1':['vec_0'],'vec_2':['vec_0'],'vec_0':[],'rank_5':['rank_1','rank_3'],'rank_3':['rank_2','rank_4','row_reduced_0','i_74'],'rank_4':['rank_1','rank_3'],'rows_11':['A_10','B_1'],'rows_12':['rows_11','arbitrary_matrix_0'],'rows_10':['rows_7','rows_8','rows_9','args_8'],'swaps_0':['iszerofunc_1','simpfunc_1','normalize_last','normalize','zero_above'],'swaps_1':['iszerofunc_3','simpfunc_2','normalize_last_0','normalize','zero_above'],'swaps_2':[],'swaps_3':['iszerofunc_6','simpfunc_4'],'L_0':[],'swaps_4':['mat_3','iszerofunc_8','simpfunc_5'],'L_2':['L_0','L_1'],'L_1':[],'nullity_3':['nullity_0','nullity_1'],'L_4':[],'nullity_2':['nullity_0','nullity_1'],'L_3':[],'nullity_1':['cols_7','val_12','i_34'],'L_6':['combined_0','combined_0'],'nullity_0':['cols_7','val_12'],'L_5':['L_3','L_4'],'size_nums_0':['block_sizes_0'],'perp_2':['perp_0'],'size_nums_1':['size_nums_0'],'L_7':['n_12','n_12'],'perp_1':['perp_0'],'size_nums_2':['size_nums_0'],'perp_0':['vec_9','ret_4'],'zeros_below_0':['iszerofunc_2'],'tmp_mat_0':['mat_0','rows_0','cols_0'],'col1_3':['col1_2','col1_1','op_0'],'col1_2':['cols_4'],'col1_5':['op_1','col_7','k_6','col1_4','col2_7'],'flat_list_11':['flat_list_10'],'flat_list_10':['args_8'],'flat_list_13':[],'possible_zeros_0':[],'flat_list_12':['flat_list_9','flat_list_11','flat_list_0','args_8'],'l_1':['l_0','primitive_0'],'flat_list_14':['flat_list_8','flat_list_12','flat_list_13','flat_list_0','args_8'],'pivot_val_2':[],'transforms_0':['N_0'],'pivot_val_1':['piv_col_3','piv_row_2','iszerofunc_5','simpfunc_3'],'l_3':['jc_0'],'pivot_val_0':['mat_0'],'l_5':['b_12'],'big_0':[],'pivot_val_9':['pivot_val_8','pivot_val_5','normalize_0','normalize_last_1'],'pivot_val_8':['pivot_val_6'],'value_2':['value_1','value_0','value_0','is_mat_0'],'pivot_val_7':['pivot_val_5','pivot_val_6'],'value_3':['value_0','value_2','j_30','i_53'],'pivot_val_6':['mat_1','piv_i_0','cols_6','piv_j_0'],'bn_5':['bn_4'],'out_0':['norm_0'],'pivot_val_5':['pivot_val_3'],'bn_6':['bn_4'],'value_1':['value_0'],'col_val_is_zero_0':['iszerofunc_17','col_val_0'],'pivot_val_4':['pivot_val_3'],'bn_3':['bn_5','bn_2'],'col_val_is_zero_1':['col_val_is_zero_0'],'pivot_val_3':['pivot_val_2','pivot_val_1','normalize_last_1'],'bn_4':['bn_2'],'col_val_is_zero_2':['col_val_is_zero_0'],'islice_0':['keys_0'],'pivot_cols_2':[],'pivot_cols_1':['iszerofunc_3','simpfunc_2','normalize_last_0','normalize','zero_above'],'pivot_cols_0':['iszerofunc_1','simpfunc_1','normalize_last','normalize','zero_above'],'block_sizes_0':['chain_0'],'cells_0':['J_2'],'block_sizes_1':['block_sizes_0'],'pivot_cols_3':['iszerofunc_9','simpfunc_6','normalize_last_2'],'block_sizes_2':['block_sizes_0'],'mml_2':['mml_3','i_45','j_24'],'mml_1':['mml_6'],'mml_0':[],'component_name_0':['i_2'],'items_2':['items_1'],'items_1':['a_7','items_0'],'items_0':['C_1'],'items_3':['items_1'],'null_big_4':['null_big_2'],'null_big_3':['null_big_2'],'null_big_2':['null_big_0'],'null_big_1':['null_big_3','null_big_0'],'null_big_0':['eig_3','size_2'],'op_2':['op_1','col_7','k_6','col1_4','col2_7'],'k_7':['op_1','col_7','k_6','col1_4','col2_7'],'op_4':['op_3','row_3','k_8','row1_1','row2_2'],'op_5':['args_8'],'k_9':['op_3','row_3','k_8','row1_1','row2_2'],'row_6':['aug_0'],'op_6':['op_5','args_8'],'op_7':['op_6','args_8'],'offset_1':['offset_2','piv_row_2'],'row_4':['op_3','row_3','k_8','row1_1','row2_2'],'offset_2':['offset_4','offset_1'],'offset_3':['offset_1'],'offset_4':['offset_3'],'offset_5':['offset_3'],'J_0':[],'J_2':[],'J_1':[],'tmp_9':['tmp_6','tmp_7'],'tmp_8':['tmp_6','tmp_7'],'i_12':['i_11','i_10','i_10'],'i_11':['i_10'],'Z_0':['D_2','Y_1'],'max_dps_1':['max_dps_0','has_floats_1'],'max_dps_0':['max_prec_1'],'flat_list_5':['flat_list_4','flat_list_0','in_mat_0'],'rlo_3':['keys_0'],'rhi_3':['rlo_3'],'flat_list_6':['flat_list_5','flat_list_0','rows_6'],'rhi_2':['rhi_0','rhi_1'],'rlo_2':['rlo_0','rlo_1'],'flat_list_3':['flat_list_1','flat_list_2','flat_list_0','arr_0'],'rhi_1':['keys_0'],'flat_list_4':['in_mat_0'],'rhi_0':[],'rlo_4':['rlo_2','rlo_3','islice_0'],'flat_list_9':[],'flat_list_7':[],'flat_list_8':['flat_list_0','flat_list_0','flat_list_0','flat_list_3','flat_list_7','flat_list_0','args_8'],'tmp_5':['tmp_3'],'tmp_4':['tmp_3'],'row_swaps_1':[],'tmp_7':['tmp_8','R_5','j_41','k_19','x_28','n_15','k_19'],'row_swaps_0':['iszerofunc_0','simpfunc_0'],'tmp_6':['y_7','j_41'],'flat_list_1':['arr_0'],'tmp_1':['tmp_2','Q_0','i_75','mat_19','j_40','Q_0','i_75'],'flat_list_2':['rows_4'],'tmp_0':['mat_19','j_40'],'rlo_1':['keys_0'],'tmp_3':['tmp_0','tmp_1'],'flat_list_0':[],'rlo_0':[],'rhi_4':['rhi_2','rhi_3','islice_0'],'tmp_2':['tmp_0','tmp_1'],'j_6':['j_5'],'printer_1':[],'printer_2':['printer_1','printer_0','printer_0'],'j_7':['j_6','j_5','j_5'],'zero_0':['d_4'],'zero_1':['iszerofunc_10','ok_0','ok_0'],'zero_2':['zero_1','zero_0','zero_0'],'mml_6':['mml_0','mml_5'],'mml_5':['mml_4'],'mml_4':['mml_1','mml_2'],'vec_10':['vec_8'],'mml_3':['mml_1','mml_2'],'is_slice_0':['key_0'],'mml_7':['mml_0','mml_5'],'tmp_col_val_1':['tmp_col_val_0'],'tmp_col_val_2':['tmp_col_val_0'],'valmultpairs_0':['mat_14','mat_14'],'tmp_col_val_0':['simpfunc_12','col_val_1'],'method_5':[],'method_4':['method_3'],'i_32':[],'i_34':['i_32','i_33'],'i_33':['i_34'],'mid_0':['d_1','d_1','d_1','d_1'],'i_35':['i_32','i_33'],'Y_1':['L_5','rhs_6'],'Y_0':['L_2','rhs_2'],'method_7':[],'method_6':['method_5','method_4','method_4'],'method_8':['method_7','method_6','method_6'],'i_1':[],'i_2':['i_1','i_0','i_0'],'chop_1':['kwargs_2'],'K_inv_0':['N_2','N_2','det_inv_0','K_adj_0','m_5','N_2','N_2'],'i_25':['piv_row_2','piv_col_2'],'piv_row_1':['piv_row_2'],'piv_row_2':['piv_row_0','piv_row_1'],'i_27':['i_24','i_26'],'chop_0':['flags_1'],'y_1':['y_3','y_0'],'piv_row_0':[],'i_26':['i_25','i_27','normalize_last_1'],'y_3':['y_2'],'i_28':['i_24','i_26'],'y_2':['y_0'],'piv_row_3':['piv_row_0','piv_row_1'],'y_4':['y_2'],'y_7':['Q_1','b_16'],'y_6':['y_4','y_5'],'y_9':['y_7'],'jslice_0':['keys_0'],'y_8':['y_2','y_7'],'col_abs_1':['col_abs_0','col_11'],'col_abs_0':['col_11'],'col_11':['col_10'],'j_20':['j_16','j_18'],'berk_vector_0':[],'i_53':['key_0'],'Ukk_0':['U_1','k_18','k_18'],'AH_0':[],'Ukk_1':['Ukk_0'],'Ukk_2':['Ukk_0'],'X_2':['X_1','X_0','X_0'],'new_vecs_0':['eig_3','vec_6','size_2'],'X_1':['X_0'],'berk_vector_1':[],'eigs_0':['mat_7','flags_0'],'eigs_2':['flags_2'],'eigs_1':['mat_13'],'new_vecs_1':['new_vecs_3','new_vecs_0'],'new_vecs_2':['new_vecs_0'],'new_vecs_3':['new_vecs_2'],'new_vecs_4':['new_vecs_2'],'submat_0':[],'res_3':[],'clear_cache_2':['clear_cache_1','clear_cache_0','kwargs_1'],'res_1':['b_12','nex_3'],'clear_cache_1':['kwargs_1'],'res_2':['res_0','res_1','nr_0'],'clear_cache_0':['kwargs_1'],'res_0':['l_5'],'j_17':['piv_row_2','piv_col_2'],'j_19':['j_16','j_18'],'mat_cache_0':[],'x_3':['x_2','berk_vector_1'],'j_18':['j_17','j_19','normalize_last_1'],'x_8':['x_7','flags_0'],'ret_10':['eigenvals_0'],'x_7':['x_6','mat_4'],'ret_12':['ret_11','ret_10','primitive_0'],'ret_11':['ret_10'],'pivot_value_1':['pivot_value_3','pivot_value_0'],'pivot_value_2':['pivot_value_3','pivot_value_0'],'pivot_value_0':['sub_col_0','iszerofunc_14','simpfunc_10'],'chain_1':['chain_0'],'pivot_value_3':['pivot_value_2'],'chain_0':['eig_1'],'pivot_value_4':['pivot_value_2'],'chain_2':['chain_0'],'vals_2':['vals_0','vals_1'],'vals_1':['vals_2','k_12','v_6'],'jordan_cells_1':['jordan_cells_0'],'perm_0':['complex_0'],'vals_4':[],'eigenvals_0':['mat_10','error_when_incomplete_1','flags_1'],'vals_3':['vals_0','vals_1'],'name_0':['aug_0'],'k_13':['k_11'],'vals_0':[],'k_11':['n_5','n_5','n_5'],'k_12':['k_12','k_11'],'perm_3':[],'j_47':['j_46'],'j_49':['j_48','n_16'],'jordan_cells_0':['J_1'],'iszeropivot_5':['iszeropivot_3'],'iszeropivot_4':['iszeropivot_3'],'iszeropivot_3':['iszeropivot_0','iszeropivot_1'],'iszeropivot_2':['iszeropivot_0','iszeropivot_1'],'iszeropivot_1':['pivot_value_0'],'toeplitz_1':[],'iszeropivot_0':[],'toeplitz_0':[],'ret_4':[],'ret_5':['ret_4'],'tmp_10':['tmp_9'],'ret_2':['ret_1','pivot_cols_3'],'ret_3':['ret_2','ret_1','pivots_2'],'j_30':['key_0'],'ret_0':['pivot_val_0','tmp_mat_0','i_6','j_1','mat_0','pivot_pos_0','j_1','tmp_mat_0','i_6','cumm_0'],'simped_2':['simped_0'],'ret_1':['iszerofunc_9','simpfunc_6','normalize_last_2'],'simped_1':['simped_0'],'simped_0':['simpfunc_11','x_31'],'reduced_0':['iszerofunc_1','simpfunc_1','normalize_last','normalize','zero_above'],'cols_17':[],'w_1':['w_0','arbitrary_matrix_0'],'cols_18':['cols_15','cols_16','cols_17','args_8'],'w_0':['rows_11','cols_19'],'cols_15':['cols_10','cols_14','args_8'],'cols_16':['args_8'],'norm_0':[],'ret_8':['m_0','simplify_7'],'ret_9':['ret_8','ret_7','simplify_7','ret_7'],'ret_6':['ret_5','ret_4','normalize_1'],'cols_19':['A_10','B_1'],'tmp_11':['tmp_9'],'ret_7':['m_0'],'cols_10':['cols_8','cols_9','arr_0'],'cols_13':['cols_12','cols_11','in_mat_0'],'cols_14':['cols_13','cols_11','rows_6'],'cols_11':['ncol_0','ncol_0'],'cols_12':[],'red_0':['big_0','iszerofunc_11','simplify_8'],'reduced_1':['iszerofunc_3','simpfunc_2','normalize_last_0','normalize','zero_above'],'null_small_3':['null_small_2'],'reduced_2':['simplify_4','with_pivots_0'],'null_small_2':['null_small_0'],'reduced_3':['simplify_5'],'null_small_1':['null_small_3','null_small_0'],'ind_simplified_pairs_0':['sub_col_0','iszerofunc_14','simpfunc_10'],'reduced_4':['simplify_6','with_pivots_0'],'null_small_0':['eig_3','size_2'],'ind_simplified_pairs_2':['ind_simplified_pairs_3','ind_simplified_pairs_0'],'ind_simplified_pairs_1':['ind_simplified_pairs_3','ind_simplified_pairs_0'],'ind_simplified_pairs_4':['ind_simplified_pairs_2'],'null_small_4':['null_small_2'],'ind_simplified_pairs_3':['ind_simplified_pairs_2'],'count_11':['count_5','count_10','diagonal_0'],'pivot_col_1':['pivot_col_3'],'pivot_col_0':[],'V_0':['A_8','rank_0','rank_0'],'pivot_col_3':['pivot_col_6','pivot_col_2'],'pivot_col_2':['pivot_col_1','pivot_col_3','iszeropivot_1'],'has_floats_1':[],'pivot_col_5':['pivot_col_4'],'pivot_col_4':['pivot_col_6','pivot_col_2'],'pivot_col_7':['pivot_col_0','pivot_col_5'],'has_floats_0':[],'pivot_col_6':['pivot_col_0','pivot_col_5'],'newly_determined_0':['piv_col_3','piv_row_2','iszerofunc_5','simpfunc_3'],'newly_determined_1':['newly_determined_0'],'newly_determined_2':['newly_determined_0'],'berk_0':[],'newly_determined_3':[],'newly_determined_8':[],'count_10':['count_0','count_8'],'newly_determined_4':['col_11'],'newly_determined_5':['newly_determined_4','newly_determined_3','max_value_0'],'newly_determined_6':['newly_determined_5','newly_determined_3','iszerofunc_16','max_value_0'],'newly_determined_7':['newly_determined_6','newly_determined_3','col_11'],'j_50':['j_49','j_46'],'j_53':['j_52','j_48','n_16'],'max_value_0':['col_abs_0'],'i_85':['possible_zeros_0'],'free_sol_0':['tau_0','vt_0','V_0','tau_0','tau_0'],'j_52':['j_51','j_48','j_48'],'args_7':['args_6','attr_0'],'is_mat_2':['is_mat_1','is_mat_0','value_0','is_mat_0'],'args_2':['args_1','args_0','has_floats_1'],'is_mat_3':['is_mat_0','is_mat_2','j_30','i_53'],'max_value_1':['max_value_0','col_11'],'is_mat_0':['value_0'],'is_mat_1':[],'v_7':['A_5','A_5'],'K_adj_0':[],'args_1':['max_dps_1','chop_1','args_0'],'det_0':['row_swaps_0'],'det_1':['det_2','lu_0','k_0','k_0'],'det_2':['det_0','det_1'],'det_3':['det_0','det_1'],'diags_2':['a_0','diags_1'],'det_4':[],'diags_1':['R_0','diags_0'],'det_5':['det_4'],'phi_0':['m_5'],'ok_0':['simplify_8'],'diags_0':['C_0'],'ok_1':['ok_0','zero_0'],'ok_2':['simplify_8'],'v_13':['v_11','v_12','diagonal_0'],'v_11':['c_2','c_2'],'v_10':['c_2','c_2'],'A_11':[],'A_10':[],'jordan_basis_0':['blocks_0'],'jordan_basis_1':['jordan_basis_0','eigs_1','mat_13'],'jordan_basis_2':[],'U_1':['n_12','n_12'],'U_0':['combined_0','combined_0'],'lu_0':['iszerofunc_0','simpfunc_0'],'ret_18':[],'ret_17':[],'lu_1':[],'det_inv_0':['pow_0','det_K_0','phi_0','m_5'],'ret_19':['ret_18','ret_22','reals_only_1','val_10'],'ret_14':['ret_13','ret_12','has_floats_0'],'ret_13':['chop_0','chop_0','ret_12'],'ret_16':['ret_15'],'ret_15':[],'ret_21':['ret_20','ret_19','mult_4','basis_3'],'ret_20':[],'ret_23':['ret_17','ret_21'],'mat_11':[],'cols_8':['arr_0','arr_0'],'mat_10':['mat_9','mat_8','has_floats_0'],'ret_22':['ret_17','ret_21'],'cols_9':['arr_0'],'col2_6':['col2_5','col2_4','op_0'],'cols_6':[],'col2_5':['col1_3','col2_4','col2_4'],'cols_7':[],'cols_4':['cols_3','cols_2','cols_2'],'col2_8':['op_1','col_7','k_6','col1_4','col2_7'],'cols_5':['cols_4','op_0'],'cols_2':['col_4','k_5','col1_1','col2_2'],'vt_0':['v_7','rank_0'],'cols_3':['col_4','col1_1','col2_2'],'eJ_0':['blocks_3'],'cols_0':['mat_0'],'col2_4':['col2_3','col2_2','op_0'],'gen_0':['name_0'],'cols_1':['j_7'],'col2_3':['cols_4'],'mat_17':['mat_16','mat_15','b_7'],'mat_16':['mat_15'],'mat_19':[],'mat_18':['mat_17','mat_15','b_7','mat_15'],'mat_13':['mat_12','mat_11','has_floats_1'],'ret_25':['P_2','eJ_0','P_2'],'ret_24':[],'mat_12':['mat_11'],'mat_15':[],'mat_14':[],'clo_0':[],'Uik_4':['Uik_2'],'chi_2':['chi_0','chi_1'],'D_0':[],'Uik_3':['Uik_2'],'chi_1':['keys_0'],'Uik_2':['Uik_0'],'chi_0':[],'D_2':['D_0','D_1'],'Uik_1':['Uik_3','Uik_0'],'D_1':[],'Uik_0':['U_1','i_62','k_18'],'sub_col_3':['sub_col_2'],'sub_col_2':['sub_col_3','sub_col_0'],'chi_4':['chi_2','chi_3','jslice_0'],'chi_3':['clo_3'],'sub_col_4':['sub_col_2'],'clo_2':['clo_0','clo_1'],'clo_1':['keys_0'],'clo_4':['clo_2','clo_3','jslice_0'],'sub_col_1':['sub_col_3','sub_col_0'],'clo_3':['keys_0'],'sub_col_0':['lu_1','pivot_col_3','pivot_row_0'],'m_11':['mat_19'],'m_12':['m_11'],'rhs_6':['rhs_4','rhs_5','rhs_4'],'T_0':['n_5','n_5','n_5'],'rhs_5':['rhs_4'],'T_2':['T_0'],'components_0':['vec_3','basis_1'],'T_1':['T_0'],'rhs_2':['rhs_0','rhs_1','rhs_0'],'permutation_1':['A_7','A_7'],'permutation_0':['col_9'],'b_14':['rhs_8','perm_3'],'free_vars_0':['pivots_4'],'d_2':['b_12','nr_0'],'rhs_1':['rhs_0'],'d_4':['method_11'],'d_3':['d_2','nr_0'],'singularvalues_0':[],'piv_col_0':[],'t_1':[],'nex_3':['nex_0','nex_1'],'nex_2':['nex_0','nex_1'],'nex_4':['nex_3','nr_0'],'nex_1':['nex_2','n_9','i_55','i_55'],'nex_0':['nr_0'],'b_10':['b_9','b_7','b_7','mat_15'],'mat_8':[],'C_1':['A_3','k_11','k_11','A_3','k_11','k_11'],'C_0':[],'mat_7':['mat_6','mat_4','flags_0'],'C_3':['C_1'],'mat_9':['mat_8'],'C_2':['C_1'],'mat_4':[],'mat_3':['iszerofunc_8'],'mat_6':['mat_5','mat_4','mat_4'],'mat_5':['mat_4'],'piv_col_3':['piv_col_0','piv_col_2'],'piv_col_4':['piv_col_0','piv_col_2'],'piv_col_1':['piv_col_3'],'mat_2':['iszerofunc_6','simpfunc_4'],'mat_1':[],'piv_col_2':['piv_col_1','piv_col_3','pivot_offset_0'],'eigenvecs_4':['eigenvecs_3','eigenvecs_2','sort_0'],'pivots_0':['iszerofunc_6','simpfunc_4'],'pivots_1':['mat_3','iszerofunc_8','simpfunc_5'],'pivots_3':['simplify_4','with_pivots_0'],'pivots_4':['simplify_5'],'pivots_5':['simplify_6','with_pivots_0'],'pivots_6':['small_basis_0','v_1','with_pivots_0'],'pivots_7':['pivots_6'],'pivots_8':['pivots_6'],'pivots_9':['aug_0','simplify_8'],'x_22':['x_24','x_21'],'row1_2':['op_3','row_3','k_8','row1_1','row2_2'],'x_20':[],'c_2':[],'start_col_2':['start_col_0'],'start_col_0':['pivot_col_4'],'x_28':[],'start_col_1':['start_col_0'],'x_27':['x_25','x_26'],'x_25':['x_23'],'x_24':['x_23'],'x_23':['x_21'],'scale_9':['scale_4','scale_8'],'scale_6':['scale_9','scale_5'],'s_1':[],'scale_5':['A_9','i_64','j_38'],'scale_8':['A_9','i_64','i_64'],'s_3':['s_5','s_2'],'scale_7':['scale_5'],'s_2':['printer_3','i_77','j_42'],'s_5':['s_4'],'s_4':['s_2'],'s_6':['s_4'],'x_10':['x_9','simplify_7'],'x_14':['x_13','has_floats_1'],'x_12':['x_11','x_10','has_floats_0'],'normalize_1':['kwargs_0'],'R_0':[],'arbitrary_matrix_1':['cols_19','rows_11','w_0'],'arbitrary_matrix_2':['arbitrary_matrix_1','arbitrary_matrix_0','arbitrary_matrix_0'],'R_2':['R_1'],'R_1':['A_3','k_11','k_11','A_3','k_11','k_11'],'R_4':['mat_19','n_14','m_11','mat_19','m_11'],'R_3':['R_1'],'R_5':[],'pivot_offset_1':['pivot_offset_0'],'rows_6':['in_mat_0','cols_11'],'pivot_offset_2':['pivot_offset_0'],'rows_7':['rows_5','rows_6','args_8'],'echelon_form_0':['mat_3','iszerofunc_8','simpfunc_5'],'rows_8':['args_8'],'pivot_offset_0':['piv_col_3','piv_row_2','iszerofunc_5','simpfunc_3'],'rows_9':[],'rows_2':[],'cols_20':['cols_19','arbitrary_matrix_0'],'rows_3':['arr_0','arr_0'],'pivot_row_offset_4':['pivot_row_offset_2'],'rows_4':['arr_0'],'pivot_row_offset_3':['pivot_row_offset_2'],'rows_5':['rows_3','rows_4','arr_0'],'pivot_row_offset_2':['pivot_row_offset_3','pivot_row_offset_0'],'rows_0':['mat_0','pivot_pos_0'],'rows_1':['i_12'],'row2_3':['op_3','row_3','k_8','row1_1','row2_2'],'scale_2':['scale_0'],'scale_1':['scale_3','scale_0'],'b_8':['b_7'],'scale_4':['scale_2'],'scale_3':['scale_2'],'pivot_row_offset_1':['pivot_row_offset_3','pivot_row_offset_0'],'b_9':['b_8','b_7','b_7'],'pivot_row_offset_0':['sub_col_0','iszerofunc_14','simpfunc_10'],'scale_0':['A_9','i_63','j_37'],'n_13':[],'p_cols_0':[],'n_12':[],'n_10':['n_9','nr_0'],'p_cols_3':['p_cols_0','p_cols_1'],'p_cols_4':['p_cols_3'],'p_cols_1':['p_cols_2','basis_2'],'n_15':['R_5'],'p_cols_2':['p_cols_0','p_cols_1'],'n_14':['mat_19'],'p_cols_5':['p_cols_4','p_cols_3','normalize_2'],'A_0':[],'x_31':['x_29'],'A_1':[],'x_30':['x_23','x_29'],'A_2':['A_3','k_11','k_11','A_3','k_11','k_11'],'A_3':['A_1','A_2'],'A_4':['A_1','A_2'],'A_5':['aug_0','simplify_8'],'A_6':['A_5','A_5'],'A_7':['A_6','A_6','permutation_0'],'item_1':['item_0','attr_0'],'A_8':['A_7','A_7'],'A_9':[],'eigenvecs_0':[],'eigenvecs_1':['simplify_6'],'eigenvecs_2':['eigenvecs_1','eigenvecs_0','eigenvecs_0'],'eigenvecs_3':['eigenvecs_2'],'pivots_10':['col_9','pivots_9'],'Q_1':[],'Q_0':['mat_19','n_14','m_11','mat_19','m_11'],'det_K_0':[],'tau_0':['gen_0','col_9','rank_0','col_9','rank_0'],'sol_0':['col_9'],'index_1':['index_0','col_11'],'a_0':[],'blocks_0':['eigs_1'],'index_0':['col_abs_0','max_value_0'],'a_7':['A_3','k_11','k_11','A_3','k_11','k_11'],'blocks_3':['cells_0'],'blocks_2':['mat_13','block_structure_0'],'a_9':['a_7'],'blocks_1':['blocks_0','eigs_1','mat_13'],'a_8':['a_7'],'pivot_pos_0':['mat_0'],'work_0':['n_8'],'q_0':['j_16','i_24','cols_6'],'scale_10':['scale_8'],'in_mat_0':[],'in_mat_2':['in_mat_1','args_8'],'in_mat_1':['in_mat_0','args_8'],'combined_0':['iszerofunc_13','simpfunc_9','rankcheck_0'],}

#added phi names
phi_names_set = {'i_2','det_2','det_3','method_6','method_8','i_12','j_7','col_4','cols_4','col2_4','cols_5','col1_3','col_6','col2_6','pivot_val_4','val_4','offset_4','newly_determined_1','i_27','assumed_nonzero_1','j_19','piv_row_2','pivot_offset_1','piv_col_3','offset_2','offset_3','piv_col_2','pivot_val_3','i_26','j_18','val_2','val_3','pivot_val_5','val_5','offset_5','newly_determined_2','i_28','assumed_nonzero_2','j_20','piv_row_3','pivot_offset_2','piv_col_4','pivot_val_7','pivot_val_8','pivot_val_9','det_5','ret_3','vec_1','vec_2','perp_1','perp_2','ret_6','eigenvecs_2','eigenvecs_4','p_cols_2','p_cols_3','p_cols_5','mat_6','x_7','mat_7','x_8','x_10','simpfunc_8','mat_10','x_12','ret_9','ret_12','l_1','ret_14','clear_cache_2','ret_16','ret_22','ret_19','ret_21','ret_23','max_dps_1','max_prec_2','args_2','i_34','nullity_2','i_35','nullity_3','pivots_7','pivots_8','mat_13','x_14','basis_mat_1','jordan_basis_1','blocks_1','jordan_mat_1','chain_1','size_nums_1','block_sizes_1','chain_2','size_nums_2','block_sizes_2','vec_9','null_small_3','new_vecs_3','null_big_3','eig_basis_1','vec_7','null_small_1','new_vecs_1','null_big_1','vec_8','null_small_2','new_vecs_2','null_big_2','vec_10','null_small_4','new_vecs_4','null_big_4','eig_basis_2','vals_2','vals_3','X_2','m_6','n_4','sign_3','sign_4','A_3','a_8','R_2','C_2','T_1','k_12','items_2','A_4','a_9','R_3','C_3','T_2','k_13','items_3','args_7','item_1','item_doit_1','mml_6','mml_3','mml_4','mml_7','bn_5','bn_3','bn_2','bn_4','bn_6','printer_2','flat_list_3','rows_5','cols_10','flat_list_5','cols_13','flat_list_6','cols_14','arr_1','in_mat_1','ncol_1','flat_list_8','rows_7','cols_15','op_6','flat_list_12','arr_2','in_mat_2','ncol_2','op_7','flat_list_14','rows_10','cols_18','is_mat_2','value_2','key_4','key_5','is_mat_3','value_3','key_6','L_2','rhs_2','mat_17','b_9','mat_18','b_10','prod_1','acum_6','acum_4','acum_2','acum_3','acum_5','acum_7','acum_15','acum_12','acum_10','acum_11','acum_13','acum_16','nex_2','nex_3','nex_4','res_2','d_3','n_10','zero_2','ok_1','rhi_2','rlo_2','rhi_4','rlo_4','chi_2','clo_2','chi_4','clo_4','D_2','L_5','rhs_6','pivot_value_3','ind_simplified_pairs_3','sub_col_3','pivot_col_6','is_assumed_non_zero_3','candidate_pivot_row_1','start_col_1','iszeropivot_4','pivot_row_offset_3','pivot_value_1','ind_simplified_pairs_1','sub_col_1','pivot_col_3','is_assumed_non_zero_1','iszeropivot_2','pivot_row_offset_1','pivot_col_2','pivot_value_2','ind_simplified_pairs_2','sub_col_2','pivot_col_4','is_assumed_non_zero_2','iszeropivot_3','pivot_row_offset_2','pivot_value_4','ind_simplified_pairs_4','sub_col_4','pivot_col_7','is_assumed_non_zero_4','candidate_pivot_row_2','start_col_2','iszeropivot_5','pivot_row_offset_4','Ukk_1','Uik_3','oldpivot_2','Uik_1','Uik_2','Ukk_2','Uik_4','oldpivot_3','x_24','scale_3','y_3','x_22','scale_1','y_1','x_23','scale_2','y_2','x_25','scale_4','y_4','x_30','scale_9','y_8','x_27','scale_6','y_6','x_28','scale_7','y_7','x_31','scale_10','y_9','m_11','m_12','arbitrary_matrix_2','w_1','rows_12','cols_20','line_1','line_2','rank_4','rank_3','rank_5','tmp_4','tmp_2','tmp_3','tmp_5','tmp_10','tmp_8','tmp_9','tmp_11','s_5','s_3','s_4','s_6','count_4','count_2','count_3','count_5','count_9','count_7','count_8','count_10','v_13','count_11','j_50','j_52','j_53','newly_determined_5','newly_determined_6','col_abs_1','newly_determined_7','index_1','max_value_1','is_zero_1','is_zero_2','simped_1','is_zero_4','simped_2','is_zero_5','col_val_is_zero_1','col_val_is_zero_2','tmp_col_val_1','tmp_col_val_2',}